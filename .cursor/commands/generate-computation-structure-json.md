# Generate Computation Structure JSON from Computation Approach

Generate Computation Structure JSON from Computation Approach text. This command parses human-readable Computation Approach text and generates the structured JSON format that will be converted to optimized YAML configuration.

**AUTHORITATIVE REFERENCE**: This command must generate JSON that converts to the optimized YAML structure defined in `notion/2-documentation/1-specifications/1-databases/5-yaml-configuration/yaml-mapping-reference.yaml`. All patterns and examples must align with the 8 examples in that reference file.

**Important**: The JSON generated by this command will be optimized when converted to YAML. Redundant fields (e.g., `type: direct` in sources, `provider` when matches top-level, `description` in sources, `dependencies` when redundant with `parameters.fleeti`) will be omitted in the final YAML per optimization rules. Include all necessary fields in JSON - optimization happens during JSON→YAML conversion.

## Instructions

1. **Request input**: Accept either:
   - **CSV file**: Fleeti Fields CSV file path (preferred)
   - **Raw Computation Approach text**: Direct text input in chat
   - If neither provided, ask user which format they prefer

2. **Check export folder for existing JSON**: Before generating new JSON, check the export folder for existing Computation Structure JSON:
   - **Export folder location**: `notion/2-documentation/1-specifications/1-databases/2-fleeti-fields/export/`
   - **Look for CSV files**: Find the most recent `Fleeti Fields (db) YYYY-MM-DD.csv` file
   - **Read existing JSON**: For each field name, check if Computation Structure JSON already exists
   - **Preserve existing JSON**: If Computation Structure JSON already exists and is valid, preserve it unless Computation Approach text has changed

3. **Read input**:
   - **If CSV**: Read the CSV file and extract:
     - `Name` column: Field name
     - `Computation Approach` column: Source text to parse
     - `Field Type` column: Type of field (direct, calculated, prioritized, transformed, io_mapped)
     - `Dependencies` column: Related Fleeti fields (for calculated fields)
     - `Description` column: Field description
   - **If raw text**: Parse the provided Computation Approach text directly

4. **Compare with existing**: For each field:
   - If Computation Structure JSON exists in export folder and Computation Approach hasn't changed → preserve it
   - If Computation Approach is new or changed → generate new JSON
   - If Computation Approach is missing → skip field (with warning)

5. **Parse Computation Approach text**: For each Computation Approach text, identify the pattern and extract:
   - **Direct mapping**: Provider, field, path, description
   - **Prioritized mapping**: Multiple sources with priorities (can be all direct, mixed, or all calculated)
   - **Calculated mapping**: Function name, dependencies, parameters
   - **Transformed mapping**: Telemetry field, static field, transformation rule
   - **I/O mapped**: Raw I/O field pattern, installation metadata, default source

6. **Generate Computation Structure JSON**: Based on the parsed Computation Approach, generate JSON following these patterns (aligned with YAML reference examples):

## JSON Structure Patterns (Aligned with YAML Reference)

### 1. Direct Mapping Fields (Example 1)

**YAML Reference**: Example 1 - Single source direct mapping

**Computation Approach Pattern:**
```
"Direct mapping from {provider}: {field} (path: {path}) - {description}"
```

**Generated JSON:**
```json
[
  {
    "priority": 1,
    "type": "direct",
    "source_type": "provider",
    "provider": "{provider}",
    "field": "{field}",
    "path": "{path}",
    "description": "{description}"
  }
]
```

**YAML Structure Generated** (optimized):
```yaml
type: direct
sources:
  - field: provider_field_name
    path: provider_field_path
```

**Optimization Rules Applied**:
- `sources` array with single source (no `priority` needed for single source)
- Omit `type: direct` in source (default for provider fields)
- Omit `provider: navixy` in source (matches top-level provider)
- Omit `source_type: provider` (inferred from field/path)
- Omit `description` in source (use comments instead)

**Extraction Rules:**
- Extract provider name (lowercase: navixy, oem-trackunit, teltonika, etc.)
- Extract field name from pattern
- Extract path from `(path: {path})` or infer from field name
- Extract description from text after `-` or use Description column
- Priority is always 1 for direct mappings

**Example:**
- Computation Approach: `"Direct mapping from Navixy: lat (path: lat) - Latitude in decimal degrees"`
- Generated JSON:
```json
[
  {
    "priority": 1,
    "type": "direct",
    "source_type": "provider",
    "provider": "navixy",
    "field": "lat",
    "path": "lat",
    "description": "Latitude in decimal degrees"
  }
]
```

### 2. Prioritized Mapping Fields - Multiple Direct Sources (Example 2)

**YAML Reference**: Example 2 - Multiple direct sources with priority

**Computation Approach Pattern:**
```
"Prioritized: {provider} {field1} (path: {path1}, priority 1), then {provider} {field2} (path: {path2}, priority 2) - {description}"
```

**Generated JSON:**
```json
[
  {
    "priority": 1,
    "type": "direct",
    "source_type": "provider",
    "provider": "{provider}",
    "field": "{field1}",
    "path": "{path1}",
    "description": "{description1}"
  },
  {
    "priority": 2,
    "type": "direct",
    "source_type": "provider",
    "provider": "{provider}",
    "field": "{field2}",
    "path": "{path2}",
    "description": "{description2}"
  }
]
```

**YAML Structure Generated** (optimized):
```yaml
type: prioritized
sources:
  - priority: 1
    field: provider_field_name
    path: provider.field.path
  - priority: 2
    field: provider_field_name_2
    path: provider.field.path_2
```

**Optimization Rules Applied**:
- `priority` included for each source (multiple sources)
- Omit `type: direct` in sources (default)
- Omit `provider` in sources (all match top-level)
- Omit `source_type: provider` (inferred)
- Omit `description` in sources

**Extraction Rules:**
- Extract each source with its priority number
- Extract provider (usually same for all sources)
- Extract field name and path for each source
- Generate description for each source (can be same or specific)
- Priority increments: 1, 2, 3, etc.

**Example:**
- Computation Approach: `"Prioritized: Navixy hdop (path: hdop, priority 1), then Navixy avl_io_182 (path: params.avl_io_182, priority 2) - Horizontal Dilution of Precision"`
- Generated JSON:
```json
[
  {
    "priority": 1,
    "type": "direct",
    "source_type": "provider",
    "provider": "navixy",
    "field": "hdop",
    "path": "hdop",
    "description": "Horizontal Dilution of Precision from hdop field"
  },
  {
    "priority": 2,
    "type": "direct",
    "source_type": "provider",
    "provider": "navixy",
    "field": "avl_io_182",
    "path": "params.avl_io_182",
    "description": "Horizontal Dilution of Precision from avl_io_182"
  }
]
```

### 3. Calculated Mapping Fields (Example 3)

**YAML Reference**: Example 3 - Calculated field using function

**Computation Approach Pattern:**
```
"Calculated: derive from {dependencies} using {function_name} function. {additional_details}

Pseudo code:
{simple_pseudo_code}"
```

**Generated JSON:**
```json
[
  {
    "priority": 1,
    "type": "calculated",
    "calculation_type": "function_reference",
    "function": "{function_name}",
    "parameters": {
      "fleeti": [
        "{dependency1}",
        "{dependency2}"
      ]
    },
    "description": "{description}"
  }
]
```

**YAML Structure Generated** (optimized):
```yaml
type: calculated
calculation_type: function_reference
function: function_name
parameters:
  fleeti:
    - fleeti_field_name
    - fleeti_field_name_2
```

**Optimization Rules Applied**:
- `calculation_type: function_reference` (all calculated fields use functions)
- `parameters.fleeti` lists all Fleeti field dependencies
- Omit `dependencies` field (redundant with parameters.fleeti)
- Omit `priority` (not used for calculated in YAML)
- Omit `description` (use comments instead)
- Backend infers processing order from parameters.fleeti

**Note**: Calculated mappings do NOT use a `sources` array in YAML. They use `type: calculated` with `function` and `parameters` at the top level. The JSON structure uses an array format for consistency, but the YAML conversion script will extract the top-level fields.

**Extraction Rules:**
- Extract function name from `using {function_name} function`
- **Function name specificity**: Function names must be field-specific and unique
  - If the function name in Computation Approach is generic (e.g., `derive_last_changed_at`), make it specific based on the target field name
  - Example: For field `top_status_last_changed_at`, use `derive_top_status_last_changed_at` (not generic `derive_last_changed_at`)
  - Function names should follow pattern: `derive_{field_name}` or `derive_{category}_{field_name}`
  - This ensures each field has a unique, identifiable function name
- Extract dependencies from `derive from {dependencies}` or Dependencies column
- Dependencies should be Fleeti field names (e.g., `location_heading`, `location_latitude`)
- Generate description from additional_details or Description column
- Parameters structure: `{"fleeti": ["field1", "field2"]}` for Fleeti field dependencies

**Example:**
- Computation Approach: `"Calculated: derive from location_heading using derive_cardinal_direction function. Converts heading (0-359 degrees) to cardinal direction (N, NE, E, SE, S, SW, W, NW)."`
- Dependencies: `location_heading`
- Generated JSON:
```json
[
  {
    "priority": 1,
    "type": "calculated",
    "calculation_type": "function_reference",
    "function": "derive_cardinal_direction",
    "parameters": {
      "fleeti": [
        "location_heading"
      ]
    },
    "description": "Converts heading (0-359 degrees) to cardinal direction"
  }
]
```

### 4. Prioritized Mapping - Mixed Source Types (Example 4)

**YAML Reference**: Example 4 - Priority chain with direct provider field + calculated source

**Computation Approach Pattern:**
```
"Prioritized: {provider} {field} (path: {path}, priority 1), then calculated using {function_name} function from {dependencies} (priority 2) - {description}

Pseudo code:
{simple_pseudo_code}"
```

**Generated JSON:**
```json
[
  {
    "priority": 1,
    "type": "direct",
    "source_type": "provider",
    "provider": "{provider}",
    "field": "{field}",
    "path": "{path}",
    "description": "{description1}"
  },
  {
    "priority": 2,
    "type": "calculated",
    "calculation_type": "function_reference",
    "function": "{function_name}",
    "parameters": {
      "provider": {
        "{provider}": "{provider_field}"
      }
    },
    "description": "{description2}"
  }
]
```

**YAML Structure Generated** (optimized):
```yaml
type: prioritized
sources:
  - priority: 1
    field: provider_field_name
    path: provider.field.path
  - priority: 2
    type: calculated
    calculation_type: function_reference
    function: function_name
    parameters:
      fleeti:
        - fleeti_field_name
```

**Optimization Rules Applied**:
- Omit `type: direct` for direct sources (default)
- Keep `type: calculated` for calculated sources (not default)
- `priority` included for each source (multiple sources)
- Omit `provider` in sources (all match top-level)

**Extraction Rules:**
- Identify direct provider field (priority 1)
- Identify calculated function and dependencies (priority 2)
- Extract function name and parameters
- Determine if parameters are provider-specific or Fleeti fields

**Example:**
- Computation Approach: `"Prioritized: Navixy avl_io_1 (path: params.avl_io_1, priority 1), then calculated using extract_bit_from_bitmask function from inputs (priority 2) - Individual input 1 state."`
- Generated JSON:
```json
[
  {
    "priority": 1,
    "type": "direct",
    "source_type": "provider",
    "provider": "navixy",
    "field": "avl_io_1",
    "path": "params.avl_io_1",
    "description": "Digital Input 1 from Navixy"
  },
  {
    "priority": 2,
    "type": "calculated",
    "calculation_type": "function_reference",
    "function": "extract_bit_from_bitmask",
    "parameters": {
      "provider": {
        "navixy": "inputs"
      }
    },
    "description": "Extract bit 0 from Digital Inputs Bitmask"
  }
]
```

### 5. Prioritized Mapping - Different Provider (Example 5)

**YAML Reference**: Example 5 - Priority chain with sources from different providers

**Computation Approach Pattern:**
```
"Prioritized: {provider1} {field1} (path: {path1}, priority 1), then {provider2} {field2} (path: {path2}, priority 2) - {description}"
```

**Generated JSON:**
```json
[
  {
    "priority": 1,
    "type": "direct",
    "source_type": "provider",
    "provider": "{provider1}",
    "field": "{field1}",
    "path": "{path1}",
    "description": "{description1}"
  },
  {
    "priority": 2,
    "type": "direct",
    "source_type": "provider",
    "provider": "{provider2}",
    "field": "{field2}",
    "path": "{path2}",
    "description": "{description2}"
  }
]
```

**YAML Structure Generated** (optimized):
```yaml
type: prioritized
sources:
  - priority: 1
    field: top_provider_field_name
    path: top_provider.field.path
  - priority: 2
    provider: different_provider
    field: different_provider_field_name
    path: different_provider.field.path
```

**Optimization Rules Applied**:
- Omit `provider` for priority 1 (matches top-level)
- Include `provider` for priority 2 (different from top-level)
- Omit `type: direct` in sources (default)

**Extraction Rules:**
- Identify multiple providers mentioned
- Extract provider name for each source
- Extract field and path for each provider
- Note which provider matches top-level (omit in YAML)

**Example:**
- Computation Approach: `"Prioritized: Navixy speed (path: speed, priority 1), then Teltonika speed (path: speed, priority 2) - Vehicle speed"`
- Generated JSON:
```json
[
  {
    "priority": 1,
    "type": "direct",
    "source_type": "provider",
    "provider": "navixy",
    "field": "speed",
    "path": "speed",
    "description": "Vehicle speed from Navixy"
  },
  {
    "priority": 2,
    "type": "direct",
    "source_type": "provider",
    "provider": "teltonika",
    "field": "speed",
    "path": "speed",
    "description": "Vehicle speed from Teltonika"
  }
]
```

### 6. Transformed Mapping Fields (Example 6)

**YAML Reference**: Example 6 - Transformed field combining telemetry with static metadata

**Computation Approach Pattern:**
```
"Transformed: combine {telemetry_field} with {static_field} using transformation: {formula}. {additional_details}

Pseudo code:
{simple_pseudo_code}"
```

**Generated JSON:**
```json
[
  {
    "type": "transformed",
    "transformation": "{formula}",
    "service_fields": [
      "{static_field_path}"
    ],
    "description": "{description}"
  }
]
```

**YAML Structure Generated** (optimized):
```yaml
type: transformed
transformation: "(telemetry_field / 100) * static.tank_capacity"
service_fields:
  - asset.properties.vehicle.fuel_tank_capacity.value
```

**Optimization Rules Applied**:
- `transformation` contains formula/expression
- `service_fields` lists asset service field paths
- No `sources` array (transformed uses different structure)

**Extraction Rules:**
- Extract telemetry field from Notes
- Extract static field path (e.g., `asset.properties.vehicle.fuel_tank_capacity.value`)
- Extract transformation formula from `transformation: {formula}`
- Generate description from additional_details

**Example:**
- Computation Approach: `"Transformed: combine fuel.level_percent with asset.properties.vehicle.fuel_tank_capacity.value using transformation: (fuel.level_percent / 100) * static.tank_capacity. Calculates fuel level in liters from percentage and tank capacity."`
- Generated JSON:
```json
[
  {
    "type": "transformed",
    "transformation": "(fuel.level_percent / 100) * static.tank_capacity",
    "service_fields": [
      "asset.properties.vehicle.fuel_tank_capacity.value"
    ],
    "description": "Calculates fuel level in liters from percentage and tank capacity"
  }
]
```

### 7. I/O Mapped Fields (Example 7)

**YAML Reference**: Example 7 - I/O mapped field using installation metadata

**Computation Approach Pattern:**
```
"I/O Mapped: map {raw_io_field_pattern} to {semantic_field} using installation metadata: {installation_metadata_field}. Default source: {default_source}. {additional_details}

Pseudo code:
{simple_pseudo_code}"
```

**Generated JSON:**
```json
[
  {
    "type": "io_mapped",
    "default_source": "{default_source}",
    "installation_metadata": "{installation_metadata_field}",
    "description": "{description}"
  }
]
```

**YAML Structure Generated** (optimized):
```yaml
type: io_mapped
default_source: inputs.individual.input_1
installation_metadata: asset.installation.ignition_input_number
```

**Optimization Rules Applied**:
- `default_source` specifies fallback I/O field
- `installation_metadata` specifies asset installation field path
- No `sources` array (io_mapped uses different structure)

**Extraction Rules:**
- Extract raw I/O field pattern from Notes (e.g., `io.inputs.individual.input_N`)
- Extract installation metadata field path (e.g., `asset.installation.ignition_input_number`)
- Extract default source from `Default source: {default_source}`
- Generate description from additional_details

**Example:**
- Computation Approach: `"I/O Mapped: map io.inputs.individual.input_N to power.ignition using installation metadata: asset.installation.ignition_input_number. Default source: inputs.individual.input_1. Maps raw digital input to semantic ignition state based on installation metadata."`
- Generated JSON:
```json
[
  {
    "type": "io_mapped",
    "default_source": "inputs.individual.input_1",
    "installation_metadata": "asset.installation.ignition_input_number",
    "description": "Maps raw digital input to semantic ignition state based on installation metadata"
  }
]
```

### 8. Prioritized Mapping - All Calculated Sources (Example 8)

**YAML Reference**: Example 8 - Priority chain where all sources are calculated functions

**Computation Approach Pattern:**
```
"Prioritized: calculated using {function1_name} function from {dependencies1} (priority 1), then calculated using {function2_name} function from {dependencies2} (priority 2) - {description}

Pseudo code:
{simple_pseudo_code}"
```

**Generated JSON:**
```json
[
  {
    "priority": 1,
    "type": "calculated",
    "calculation_type": "function_reference",
    "function": "{function1_name}",
    "parameters": {
      "provider": {
        "{provider}": "{provider_field1}"
      }
    },
    "description": "{description1}"
  },
  {
    "priority": 2,
    "type": "calculated",
    "calculation_type": "function_reference",
    "function": "{function2_name}",
    "parameters": {
      "fleeti": [
        "{fleeti_field1}"
      ]
    },
    "description": "{description2}"
  }
]
```

**YAML Structure Generated** (optimized):
```yaml
type: prioritized
sources:
  - priority: 1
    type: calculated
    calculation_type: function_reference
    function: extract_bit_from_bitmask
    parameters:
      provider:
        navixy: inputs
  - priority: 2
    type: calculated
    calculation_type: function_reference
    function: alternative_function
    parameters:
      fleeti:
        - fleeti_field_name
```

**Optimization Rules Applied**:
- `type: calculated` included for all sources (not default)
- `priority` included for each source (multiple sources)
- `parameters` can use `provider:` or `fleeti:` keys
- Omit `provider` in sources (functions handle provider context)

**Extraction Rules:**
- Identify multiple calculated functions mentioned
- Extract function names and their parameters
- Determine if parameters are provider-specific or Fleeti fields
- Extract priority for each function

**Example:**
- Computation Approach: `"Prioritized: calculated using extract_bit_from_bitmask function from inputs (priority 1), then calculated using extract_bit_from_bitmask function from din (priority 2) - Individual input 1 state."`
- Generated JSON:
```json
[
  {
    "priority": 1,
    "type": "calculated",
    "calculation_type": "function_reference",
    "function": "extract_bit_from_bitmask",
    "parameters": {
      "provider": {
        "navixy": "inputs"
      }
    },
    "description": "Extract bit 0 from Digital Inputs Bitmask"
  },
  {
    "priority": 2,
    "type": "calculated",
    "calculation_type": "function_reference",
    "function": "extract_bit_from_bitmask",
    "parameters": {
      "provider": {
        "navixy": "din"
      }
    },
    "description": "Extract bit 0 from Digital Inputs Bitmask (fallback)"
  }
]
```

## Parsing Rules

### Provider Detection
- Look for provider names: `navixy`, `Navixy`, `oem-trackunit`, `OEM-Trackunit`, `teltonika`, `Teltonika`
- Case-insensitive matching
- Convert to lowercase in JSON output
- Default to `navixy` if provider not explicitly mentioned

### Path Extraction
- Extract from `(path: {path})` pattern
- If not found, infer from field name:
  - Navixy `avl_io_*` → `params.avl_io_*`
  - Navixy common fields (`lat`, `lng`, `alt`, `heading`, `speed`) → root level
  - Other providers: Use field name as path

### Function Name Extraction
- Extract from `using {function_name} function` pattern
- **IMPORTANT: Function names must be field-specific and unique**
  - Function names should include the target field name or a clear identifier to avoid ambiguity
  - Generic function names like `derive_last_changed_at` should be avoided
  - Use specific names like `derive_top_status_last_changed_at`, `derive_location_last_changed_at`, etc.
  - Function names should follow the pattern: `derive_{field_name}` or `derive_{category}_{field_name}`
- Common function name patterns:
  - `derive_{field_name}` - e.g., `derive_cardinal_direction`, `derive_geocoded_address`
  - `derive_{category}_{field_name}` - e.g., `derive_top_status_family`, `derive_top_status_code`, `derive_top_status_last_changed_at`
  - `extract_bit_from_bitmask` - Generic bitmask extraction (acceptable as it's a utility function)
  - Custom function names as specified in Computation Approach
- **Validation**: If a function name seems too generic (e.g., `derive_last_changed_at` without field context), check if it should be more specific based on the field name

### Dependencies Extraction
- Extract from `derive from {dependencies}` pattern
- Split by `and`, `,` to get multiple dependencies
- Use Dependencies column from CSV if available
- Dependencies should be Fleeti field names (underscore format: `location_heading`)

### Priority Extraction
- For prioritized mappings: Extract priority numbers from text
- For direct/calculated: Always priority 1
- Priority order: 1, 2, 3, etc. (incrementing)

## JSON Format Requirements

1. **Valid JSON**: Output must be valid JSON (can be string-escaped for CSV)
2. **Array format**: Always output as array `[{...}]` even for single sources
3. **Field names**: Use exact field names from Computation Approach
4. **Provider names**: Lowercase (navixy, oem-trackunit, teltonika)
5. **Consistent structure**: Follow the exact JSON structure patterns above
6. **Complete fields**: Include all fields needed for YAML conversion (optimization happens during conversion)

## Output

1. **Display generated Computation Structure JSON in chat**: For each field processed, display the generated JSON in a code block in the chat. This allows the user to review the generated content before it's saved to the CSV.
2. **If CSV input**: Update the CSV file with generated Computation Structure JSON in the `Computation Structure JSON` column
3. **If raw text input**: Output the JSON directly in chat (already displayed)
4. **Show a summary** of:
   - Number of fields processed
   - Number of fields with existing JSON (preserved)
   - Number of fields updated (new or changed Computation Approach)
   - Number of fields newly generated
   - Fields that couldn't be processed (with reasons)
   - Transformed/I/O mapped fields (noted with their special structure)

**Display Format**: For each field, show:
```
Field: {field_name}
Computation Structure JSON:
{generated_json}
```

## Example Workflow

**Input (CSV row):**
```csv
location_latitude,location,"Direct mapping from Navixy: lat (path: lat) - Latitude in decimal degrees",,number,,Latitude in decimal degrees,location.latitude,direct,...
```

**Generated JSON:**
```json
[
  {
    "priority": 1,
    "type": "direct",
    "source_type": "provider",
    "provider": "navixy",
    "field": "lat",
    "path": "lat",
    "description": "Latitude in decimal degrees"
  }
]
```

**Updated CSV row:**
```csv
location_latitude,location,"Direct mapping from Navixy: lat (path: lat) - Latitude in decimal degrees","[{""priority"": 1, ""type"": ""direct"", ""source_type"": ""provider"", ""provider"": ""navixy"", ""field"": ""lat"", ""path"": ""lat"", ""description"": ""Latitude in decimal degrees""}]",number,...
```

## Reference Examples

**CRITICAL**: The Computation Structure JSON generated by this command must align with the optimized YAML structure defined in:

**YAML Mapping Reference** (AUTHORITATIVE - REQUIRED READING):
- `notion/2-documentation/1-specifications/1-databases/5-yaml-configuration/yaml-mapping-reference.yaml`
- **This is the authoritative reference for the optimized YAML structure**
- Contains 8 examples covering all mapping types:
  1. Direct mapping - single source
  2. Prioritized mapping - multiple direct sources
  3. Calculated mapping - function-based
  4. Prioritized mapping - mixed (direct + calculated)
  5. Prioritized mapping - different providers
  6. Transformed mapping - telemetry + static metadata
  7. I/O mapped - installation metadata-based
  8. Prioritized mapping - all calculated sources
- Shows all optimization rules and what fields to omit/include
- The JSON→YAML conversion script uses these rules to optimize the output

**Understanding the Flow:**
```
Notes (speech-to-text) 
  → Computation Approach (generate-computation-approach-text command)
    → Computation Structure JSON (this command)
      → Optimized YAML Configuration (generate_yaml_config.py script)
```

**Key Optimization Rules (from YAML Reference):**
1. Top-level `type` field: ALWAYS KEEP (required for backend routing)
2. Source-level `type` field: OMIT when default (direct provider source), KEEP when `calculated`
3. Source-level `provider` field: OMIT when matches top-level provider
4. Source-level `priority` field: OMIT for single-source mappings
5. Source-level `description` field: OMIT (use comments instead)
6. `dependencies` field: OMIT when redundant with `parameters.fleeti`
7. `source_type` field: OMIT (can be inferred from context)

## Important Notes

- **Check export folder first**: Always check `notion/2-documentation/1-specifications/1-databases/2-fleeti-fields/export/` for existing Computation Structure JSON before generating new JSON
- **Preserve existing JSON**: If Computation Structure JSON already exists in export folder and Computation Approach hasn't changed, preserve it
- **CSV encoding**: When updating CSV, properly escape JSON strings (double quotes become `""`)
- **Validation**: Ensure generated JSON is valid and follows the exact structure patterns
- **Transformed/I/O mapped fields**: These fields use special JSON structures (not sources array) - generate the complete structure as shown in examples
- **Field name format**: Use underscore format for Fleeti field names in dependencies (e.g., `location_heading`, not `location.heading`)
- **Provider names**: Always lowercase in JSON output (navixy, oem-trackunit, teltonika)
- **Function name specificity**: Function names must be field-specific and unique. Avoid generic function names like `derive_last_changed_at` - use specific names like `derive_top_status_last_changed_at` that include the target field context. Function names should follow the pattern `derive_{field_name}` or `derive_{category}_{field_name}` to ensure uniqueness and clarity.
- **YAML optimization**: The JSON generated by this command will be optimized when converted to YAML. Include all necessary fields in JSON (even if they'll be omitted in YAML) - the optimization happens during JSON→YAML conversion. See `yaml-mapping-reference.yaml` for what fields are omitted and why.
- **Complete JSON structure**: Generate complete JSON structures that include all fields needed for YAML conversion. The conversion script will handle optimization by omitting redundant fields per the rules in `yaml-mapping-reference.yaml`.
- **YAML alignment**: All generated Computation Structure JSON must align with the 8 examples in `yaml-mapping-reference.yaml` - refer to that file as the authoritative specification for the final YAML output structure.
