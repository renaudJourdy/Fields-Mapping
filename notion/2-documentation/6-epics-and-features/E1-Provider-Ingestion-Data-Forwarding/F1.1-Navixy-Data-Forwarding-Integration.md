# Description

The Navixy Data Forwarding Integration feature establishes and maintains connections to Navixy's Data Forwarding service to receive real-time telemetry packets from GPS tracking devices. This feature receives raw telemetry packets, parses them into structured data, and forwards the parsed data to the transformation pipeline for conversion to Fleeti telemetry format.

This feature is the entry point of the telemetry ingestion pipeline, enabling real-time data flow from Navixy devices into the Fleeti system. It ensures data integrity, handles connection management, and provides the foundation for all downstream telemetry processing.

**Value Delivered:**
- Real-time telemetry ingestion from Navixy devices
- Foundation for provider-agnostic telemetry system
- Enables live map updates and real-time asset tracking
- Supports historical data collection and analysis

**System Context:**
This feature sits at the beginning of the telemetry pipeline: **Ingestion (F1.1) → Transformation (F2.1) → Storage (E4) → Consumption (E6)**. It receives raw provider data and prepares it for transformation into Fleeti canonical format.

---

# Business Logic / Processing Logic

## Core Rules and Priorities

**Processing Order:**
1. Packets must be processed in strict sequential order as received
2. Per-gateway processing maintains order (packets for same gateway processed sequentially)
3. Different gateways can be processed in parallel

**Data Integrity Rules:**
- All packets must be traceable to original raw packet
- No data loss: All valid packets must be processed
- Invalid packets are skipped but logged for investigation
- Duplicate packets are handled correctly (idempotency)

**Connection Rules:**
- One connection per customer (managed by F1.3 - Customer Management)
- Connection must be maintained continuously for active customers
- Automatic reconnection on connection failure
- Connection status tracked per customer

## Processing Steps

The feature processes incoming telemetry packets through the following sequential steps:

1. **Packet Received**
   - Receive raw telemetry packet from Navixy Data Forwarding endpoint
   - Packet arrives in Navixy-specific format

2. **Parse Packet Data**
   - Parse raw packet into structured JSON object
   - Extract gateway IMEI from packet
   - Extract telemetry fields and metadata
   - Validate packet structure and required fields

3. **Fetch Asset Object**
   - Query MongoDB (Asset Service) using gateway IMEI
   - Retrieve asset configuration and metadata
   - Handle case where asset is not found (alert and skip packet)

4. **Fetch Cached State**
   - Retrieve latest previous cached state for the gateway from Redis
   - If cached state unavailable, proceed with empty/default state
   - Cache state used for stateful processing and comparisons
   - **Developer Documentation Required:** Redis key structure, cached state data schema, TTL/expiration policies, and cache invalidation logic should be documented by the development team

5. **Call Mapping Function**
   - Invoke transformation mapping function with:
     - Parsed packet data (JSON object)
     - Asset object (from MongoDB)
     - Cached gateway state
     - YAML configuration file
   - Mapping function applies YAML configuration to transform provider data
   - Forward transformed data to transformation pipeline
   - **Developer Note:** Mapping function signature, input/output formats, and implementation details are specified in the YAML configuration documentation and pseudo-code.

**Processing Flow:**
```
Raw Packet → Parse → Fetch Asset → Fetch Cache → Map → Transformation Pipeline
```

## Edge Cases and Error Handling

**Asset Not Found:**
- **Condition:** Gateway IMEI does not exist in MongoDB
- **Handling:** Log error, track in error visualization system, skip packet processing
- **Reason:** Cannot process packet without asset context
- **Note:** Error tracked via visualization system (not email/Teams alerts)

**Cached State Unavailable:**
- **Condition:** No cached state found for gateway
- **Handling:** Proceed with empty/default state
- **Reason:** Processing can continue without historical state

**Packet Parsing Failure:**
- **Condition:** Invalid packet format, missing required fields, malformed data
- **Handling:** Skip packet, log error with packet details, continue processing next packet
- **Reason:** Invalid data should not block processing of valid packets

**MongoDB Unavailable:**
- **Condition:** MongoDB temporarily unavailable when fetching asset
- **Handling:** Retry with exponential backoff, queue packet if retries exhausted
- **Reason:** Temporary service unavailability should not cause data loss

**Mapping Function Failure:**
- **Condition:** YAML file missing, mapping function error, transformation failure
- **Handling:** Skip packet, log error, track in error visualization system
- **Reason:** Mapping errors indicate configuration issues that need attention
- **Note:** Error tracked via visualization system (not email/Teams alerts)

**YAML Configuration Changes:**
- **Condition:** YAML mapping file updated during processing
- **Handling:** Reload YAML configuration and continue processing with new mapping
- **Reason:** Configuration updates should be applied immediately

**Simultaneous Packets (Same Gateway):**
- **Condition:** Multiple packets arrive for same gateway at same time
- **Handling:** Process sequentially, maintain strict ordering per gateway
- **Reason:** Prevents race conditions and ensures state consistency

**Packet Ordering:**
- **Requirement:** Process packets in strict sequential order as received
- **Handling:** Maintain processing queue per gateway, process one packet at a time per gateway
- **Reason:** Ensures correct state transitions and data consistency

## State Management

**Connection State (Per Customer):**
- **Connected:** Active connection receiving packets
- **Disconnected:** Connection lost, attempting reconnection
- **Suspended:** Customer data forwarding suspended (managed by F1.3)
- **Error:** Connection error, requires intervention

**Gateway Processing State:**
- **Last Packet Timestamp:** Track last successfully processed packet per gateway
- **Processing Status:** Currently processing, idle, error
- **Error Count:** Track consecutive errors per gateway

**State Persistence:**
- Connection state persisted for recovery after system restart
- Gateway processing state cached for performance
- Last packet timestamp stored for gap detection (used by F1.5 - Data Recovery)

---

## External Service Contracts

**Navixy Data Forwarding Service:**
- **Service:** Navixy Data Forwarding endpoint
- **Connection Method:** Provider-specific (documented in wiki - see Developer Documentation Requirements below)
- **Authentication:** Customer-specific credentials (managed by F1.3)
- **Data Format:** Raw telemetry packets in Navixy format
- **Packet Structure:** See [Raw Packet Structure]
- **Developer Note:** Connection protocol, endpoint URL structure, authentication mechanism, and connection establishment details have been investigated by the development team and should be documented in the wiki. Reference the wiki documentation for implementation details.

**MongoDB (Asset Service):**
- **Service:** Asset Service database
- **Query:** Fetch asset by gateway IMEI
- **Data Required:** Asset configuration, metadata, customer association
- **Availability:** Must be available for packet processing (retry on failure)isolated application component. Developers are already familiar with the asset schema and query structure.

**Transformation Pipeline:**
- **Integration:** Forward parsed packet data to transformation pipeline
- **Data Format:** Parsed JSON object with asset context and cached state
- **Trigger:** Invoke mapping function with YAML configuration
- **Dependency:** F2.1 - YAML Configuration Execution
- **Developer Note:** The integration method (message queue, API call, event stream) is up to the development team to choose based on system architecture. The feature documentation describes the required data flow, but implementation details are left to developers.

## Connection Management

**Connection Lifecycle:**
- **Establish:** Connect to Navixy endpoint per customer (triggered by F1.3)
- **Maintain:** Keep connection active, monitor health
- **Reconnect:** Automatic reconnection on failure with exponential backoff
- **Terminate:** Close connection when customer removed or suspended

**Connection Health:**
- Monitor connection status per customer
- Detect connection failures (partial and total)
- Track connection metrics (uptime, packet rate, errors)
- Integration with F1.4 - Health Monitoring for alerting

**Per-Customer Isolation:**
- Each customer has independent connection
- Customer credentials managed separately
- Connection failures isolated per customer
- No cross-customer data leakage
- **Developer Note:** Credential retrieval mechanism is already known to the development team. If credential storage/retrieval details are not yet documented, developers should document this in the wiki for future reference.

## Error Handling

**Error Classification:**
- **Connection Errors:** Network failures, authentication failures, service unavailable
- **Data Errors:** Invalid packet format, missing fields, parsing failures
- **Integration Errors:** MongoDB unavailable, transformation pipeline unavailable
- **Configuration Errors:** Missing YAML file, invalid mapping configuration

**Retry Logic:**
- **Connection Failures:** Retry with exponential backoff, alert after max retries
- **MongoDB Failures:** Retry with exponential backoff, queue packet if retries exhausted
- **Transient Errors:** Retry automatically, log for monitoring
- **Permanent Errors:** Skip packet, log for investigation (errors tracked via visualization system, not alerts)

**Error Recovery:**
- Automatic reconnection on connection failure
- Queue packets during temporary service unavailability
- Resume processing after service recovery
- Integration with F1.5 - Data Recovery for gap handling

## Health Monitoring

**Metrics Tracked:**
- Packets received per customer per time period
- Packets processed successfully per customer
- Packets skipped/failed per customer
- Processing latency (packet receipt to transformation)
- Connection uptime per customer
- Error rates per customer

**Error Visualization and Tracking:**
- **No Email/Teams Alerts:** Errors should NOT trigger email or Microsoft Teams notifications to avoid spam when errors occur frequently (e.g., every second)
- **Visualization System Required:** Implement a dashboard/visualization system to track:
  - Current processing status (packets processed successfully vs failed)
  - Error rates and trends over time
  - Unprocessed data queues
  - Connection health status per customer
  - Processing latency metrics
- **Real-time Visibility:** System should provide real-time visibility into:
  - Packets being processed successfully
  - Packets being skipped/failed (with error reasons)
  - Processing backlog size
  - Connection status per customer
- **Error Investigation:** Visualization system should enable investigation of:
  - Error patterns and trends
  - Specific error details for troubleshooting
  - Historical error data
- **Integration:** Error visualization integrates with F1.4 - Health Monitoring for comprehensive system visibility

**Status Reporting:**
- Connection status per customer (exposed to F1.4 - Health Monitoring)
- Processing metrics per customer
- Error summaries and trends (via visualization system)
- Integration with monitoring systems

## Data Recovery Procedures

**Gap Detection:**
- Compare packet timestamps with expected intervals
- Detect missing packets or time gaps
- Trigger recovery workflow (handled by F1.5 - Data Recovery)

**Recovery Integration:**
- Provide last packet timestamp per gateway
- Support recovery workflow triggers
- Handle recovered packets through normal processing flow

---

# Performance Requirements

**Latency Requirements:**
- **Packet Processing:** Process packets in real-time (within seconds of receipt)
- **End-to-End:** Packet receipt → Transformation pipeline: < 5 seconds (p95)
- **Connection Recovery:** Reconnect within 30 seconds of failure detection

**Throughput Requirements:**
- **Per Customer:** Handle packet rate as delivered by Navixy (no artificial throttling)
- **System Capacity:** Support concurrent processing for all active customers
- **Peak Handling:** Handle 2-3x average packet rate during peak periods

**Resource Usage:**
- **Connection Overhead:** Minimize connection resources per customer
- **Processing Efficiency:** Process packets without blocking or queuing delays under normal load
- **Memory Usage:** Efficient caching of gateway state without excessive memory consumption

---

# Acceptance Criteria

## AC1 - Successful Packet Processing

**Given** a valid telemetry packet is received from Navixy  
**When** the packet is processed  
**Then** the packet is parsed into JSON, asset is fetched from MongoDB, cached state is retrieved, mapping function is called with YAML configuration, and transformed data is forwarded to transformation pipeline

## AC2 - Asset Not Found Handling

**Given** a packet is received with gateway IMEI that doesn't exist in MongoDB  
**When** the system attempts to fetch the asset  
**Then** error is logged with IMEI and packet details, error is tracked in visualization system, and the packet is skipped without blocking other packet processing

## AC3 - Cached State Unavailable

**Given** a packet is received for a gateway with no cached state  
**When** the system attempts to fetch cached state  
**Then** processing continues with empty/default state and packet is processed normally

## AC4 - Packet Parsing Failure

**Given** a packet is received with invalid format or missing required fields  
**When** the system attempts to parse the packet  
**Then** the packet is skipped, error is logged with packet details, and processing continues with next packet

## AC5 - MongoDB Unavailability

**Given** MongoDB is temporarily unavailable when fetching asset  
**When** the system attempts to fetch asset  
**Then** the system retries with exponential backoff, and if retries are exhausted, the packet is queued for later processing

## AC6 - Mapping Function Failure

**Given** YAML mapping file is missing or mapping function encounters an error  
**When** the system attempts to call mapping function  
**Then** the packet is skipped, error is logged, error is tracked in visualization system, and processing continues with next packet

## AC7 - Sequential Processing Per Gateway

**Given** multiple packets arrive simultaneously for the same gateway  
**When** packets are processed  
**Then** packets are processed sequentially (one at a time) for that gateway, maintaining strict order

## AC8 - YAML Configuration Reload

**Given** YAML mapping file is updated during packet processing  
**When** a new packet is processed  
**Then** the system reloads YAML configuration and processes the packet with the new mapping

## AC9 - Connection Recovery

**Given** connection to Navixy is lost  
**When** connection failure is detected  
**Then** the system automatically attempts reconnection with exponential backoff, and resumes packet processing when connection is restored

## AC10 - Data Traceability

**Given** a packet is successfully processed  
**When** transformed data is stored  
**Then** the transformed data is linked to the original raw packet, enabling traceability for troubleshooting and audit

---

# References

## Related Documentation
- [Epic 1 - Provider Ingestion & Data Forwarding]
- [F1.3 - Customer Management for Data Forwarding]
- [F1.4 - Data Forwarding Health Monitoring]
- [F1.5 - Data Recovery System]
- [F2.1 - YAML Configuration Execution]

---

# Non-Goals

- **Customer Management:** Adding/removing customers from data forwarding (handled by F1.3)
- **Health Monitoring UI:** Dashboards and monitoring interfaces (handled by F1.4)
- **Data Recovery UI:** Manual recovery triggers and workflows (handled by F1.5)
- **Transformation Logic:** Field mapping and transformation rules (handled by F2.1)
- **Storage Implementation:** Cold storage implementation details (handled by E4)
- **Frontend Integration:** User-facing features and interfaces (handled by mobile/web apps)
- **Email/Teams Alerts:** Direct email or Microsoft Teams notifications for errors (errors tracked via visualization system instead)

---

# Developer Documentation Requirements

The following items should be documented by the development team during or after implementation:

1. **Navixy Connection Details:**
   - Connection protocol (WebSocket, HTTP streaming, TCP socket, etc.)
   - Endpoint URL structure
   - Authentication mechanism and flow
   - Connection establishment handshake
   - Packet delivery method
   - **Location:** Document in wiki/developer documentation

2. **Redis Cached State Structure:**
   - Redis key naming convention and structure
   - Cached state data schema/structure
   - TTL and expiration policies
   - Cache invalidation logic
   - **Location:** Document in wiki/technical pages

3. **Credential Storage and Retrieval (if not already documented):**
   - How customer credentials are stored
   - Credential retrieval mechanism
   - Security considerations
   - **Location:** Document in wiki/technical pages if not already available

4. **Error Visualization System:**
   - Dashboard/visualization system architecture
   - Data collection and storage for metrics
   - Visualization interface design
   - Real-time update mechanism
   - **Location:** Document in wiki/technical pages