Name,Category,Computation Approach,Computation Structure,Data Type,Dependencies,Description,Field Path,Field Type,Example,Mapping Fields (db),Notes,Priority,REST API Endpoints,Status,Structure Type,Unit,Version Added,WebSocket Contracts,ðŸ’½ Provider Field (db)
last_updated_at,metadata,(msg_time),,date,,"Timestamp of when the telemetry record was originally created on the GPS tracker device, before transmission to the provider.",last_updated_at,direct,"""""""""2025-01-18T14:30:45Z""""""""",,,,,inactive,simple_value,,1.0.0,,
asset,metadata,,,object,,,asset,direct,,,,,,inactive,nested_object,,1.0.0,,
status,metadata,,,object,,,status,direct,,,,,,inactive,nested_object,,1.0.0,,
location,metadata,,,object,,,location,direct,,,,,,inactive,nested_object,,1.0.0,,
provider,metadata,,,object,,,provider,direct,,,,,,inactive,nested_object,,1.0.0,,
asset,metadata,,,object,,,asset,direct,"""""""{""id"": ""uuid"", ""name"": ""string"", ""type"": 10, ""subtype"": 110, ""group"": {""id"": ""uuid"", ""name"": ""string""}, ""customer_ref"": ""2010-010"", ""accessories"": [{""id"": ""uuid"", ""type_id"": 1, ""type_code"": ""immobilizer"", ""connection"": ""wire"", ""label"": ""Main immobilizer relay""}, {""id"": ""uuid"", ""type_id"": 2, ""type_code"": ""temperature"", ""connection"": ""bluetooth"", ""label"": ""Cold room sensor"", ""sensors"": [{""type"": ""temperature"", ""position"": 1}, {""type"": ""humidity"", ""position"": 1}]}, {""id"": ""uuid"", ""type_id"": 3, ""type_code"": ""fuel_level"", ""connection"": ""wire"", ""label"": ""Fuel probe 1"", ""serial_number"": ""LLS-00933"", ""sensors"": [{""type"": ""fuel_level"", ""position"": 1}]}], ""installation"": {""ignition_input_number"": 1, ""immobilizer_output_number"": 2, ""initial_odometer"": {""value"": 154000, ""unit"": ""km""}, ""initial_engine_hours"": {""value"": 4200, ""unit"": ""h""}}, ""properties"": {""vehicle"": {""serial_number"": ""string"", ""brand"": ""string"", ""model"": ""string"", ""license_plate"": ""string"", ""vin"": ""string"", ""powertrain"": {""primary_energy"": ""diesel|gasoline|electric|hybrid|cng|lng|hydrogen|other"", ""fuel_tank_capacity"": {""value"": 600, ""unit"": ""l""}, ""battery_capacity"": {""value"": 120, ""unit"": ""kwh""}, ""theoretical_consumption"": {""value"": 32.5, ""unit"": ""l/100km""}, ""theoretical_consumption_kwh"": {""value"": 24.3, ""unit"": ""kwh/100km""}}}, ""equipment"": {""serial_number"": ""string"", ""brand"": ""string"", ""model"": ""string"", ""rated_power"": {""value"": 180, ""unit"": ""kw""}, ""energy_source"": ""diesel|electric|hybrid""}, ""phone"": {""platform"": ""ios|android|unknown"", ""platform_version"": ""17.2"", ""employee_id"": ""string"", ""employee_name"": ""string""}, ""site"": {""name"": ""Abidjan Coldroom West"", ""address"": {""line1"": ""Zone industrielle"", ""city"": ""Abidjan"", ""country"": ""CI""}, ""location"": {""latitude"": 5.3561, ""longitude"": -4.0083}, ""surface"": {""value"": 120, ""unit"": ""m2""}, ""capacity_units"": 450, ""temperature_range"": {""min"": {""value"": -25, ""unit"": ""Â°C""}, ""max"": {""value"": 5, ""unit"": ""Â°C""}}}}}""""""",,,,,inactive,nested_object,,1.0.0,,
asset_id,metadata,,,string,,,asset.id,direct,"""""""""uuid""""""""",,,,,inactive,simple_value,,1.0.0,,
asset_name,metadata,,,string,,,asset.name,direct,"""""""""string""""""""",,,,,inactive,simple_value,,1.0.0,,
asset_type,metadata,,,number,,,asset.type,direct,"""""""10""""""",,,,,inactive,simple_value,,1.0.0,,
asset_subtype,metadata,,,number,,,asset.subtype,direct,"""""""110""""""",,,,,inactive,simple_value,,1.0.0,,
asset_group,metadata,,,object,,,asset.group,direct,"""""""{""id"": ""uuid"", ""name"": ""string""}""""""",,,,,inactive,nested_object,,1.0.0,,
asset_group_id,metadata,,,string,,,asset.group.id,direct,"""""""""uuid""""""""",,,,,inactive,simple_value,,1.0.0,,
asset_group_name,metadata,,,string,,,asset.group.name,direct,"""""""""string""""""""",,,,,inactive,simple_value,,1.0.0,,
asset_customer_ref,metadata,,,string,,,asset.customer_ref,direct,"""""""""2010-010""""""""",,,,,inactive,simple_value,,1.0.0,,
asset_accessories,metadata,,,array,,,asset.accessories[],direct,"""""""[{""id"": ""uuid"", ""type_id"": 1, ""type_code"": ""immobilizer"", ""connection"": ""wire"", ""label"": ""Main immobilizer relay""}, {""id"": ""uuid"", ""type_id"": 2, ""type_code"": ""temperature"", ""connection"": ""bluetooth"", ""label"": ""Cold room sensor"", ""sensors"": [{""type"": ""temperature"", ""position"": 1}, {""type"": ""humidity"", ""position"": 1}]}, {""id"": ""uuid"", ""type_id"": 3, ""type_code"": ""fuel_level"", ""connection"": ""wire"", ""label"": ""Fuel probe 1"", ""serial_number"": ""LLS-00933"", ""sensors"": [{""type"": ""fuel_level"", ""position"": 1}]}]""""""",,,,,inactive,array,,1.0.0,,
asset_accessories_id,metadata,,,string,,,asset.accessories[].id,direct,"""""""""uuid""""""""",,,,,inactive,simple_value,,1.0.0,,
asset_accessories_type_id,metadata,,,number,,,asset.accessories[].type_id,direct,"""""""1""""""",,,,,inactive,simple_value,,1.0.0,,
asset_accessories_type_code,metadata,,,string,,,asset.accessories[].type_code,direct,"""""""""immobilizer""""""""",,,,,inactive,simple_value,,1.0.0,,
asset_accessories_connection,metadata,,,string,,,asset.accessories[].connection,direct,"""""""""wire""""""""",,,,,inactive,simple_value,,1.0.0,,
asset_accessories_label,metadata,,,string,,,asset.accessories[].label,direct,"""""""""Main immobilizer relay""""""""",,,,,inactive,simple_value,,1.0.0,,
asset_installation,metadata,,,object,,,asset.installation,direct,"""""""{""ignition_input_number"": 1, ""immobilizer_output_number"": 2, ""initial_odometer"": {""value"": 154000, ""unit"": ""km""}, ""initial_engine_hours"": {""value"": 4200, ""unit"": ""h""}}""""""",,,,,inactive,nested_object,,1.0.0,,
asset_installation_ignition_input_number,metadata,,,number,,,asset.installation.ignition_input_number,direct,"""""""1""""""",,,,,inactive,simple_value,,1.0.0,,
asset_installation_immobilizer_output_number,metadata,,,number,,,asset.installation.immobilizer_output_number,direct,"""""""2""""""",,,,,inactive,simple_value,,1.0.0,,
asset_installation_initial_odometer,metadata,,,object,,,asset.installation.initial_odometer,direct,"""""""{""value"": 154000, ""unit"": ""km""}""""""",,,,,inactive,value_unit_object,km,1.0.0,,
asset_installation_initial_engine_hours,metadata,,,object,,,asset.installation.initial_engine_hours,direct,"""""""{""value"": 4200, ""unit"": ""h""}""""""",,,,,inactive,value_unit_object,h,1.0.0,,
top_status_family,status,"Calculated: derive from statuses.connectivity.code, statuses.immobilization.code, statuses.engine.code, and statuses.transit.code using derive_top_status_family function. Evaluates status families in conditional priority order: (1) Connectivity if compatible and code = ""offline"", (2) Immobilization if compatible and code = ""immobilized"", (3) Engine if compatible and code = ""running"", (4) Transit if compatible, (5) Connectivity fallback (code = ""online""). Returns the family name (connectivity/immobilization/engine/transit) of the selected status family. Backend must check asset type/subtype compatibility for each status family before evaluation.

Pseudo code:
if (connectivity.compatible && connectivity.code === ""offline"") {
  return ""connectivity""
} else if (immobilization.compatible && immobilization.code === ""immobilized"") {
  return ""immobilization""
} else if (engine.compatible && engine.code === ""running"") {
  return ""engine""
} else if (transit.compatible) {
  return ""transit""
} else {
  return ""connectivity""  // fallback (online)
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""derive_top_status_family"",
    ""parameters"": {
      ""fleeti"": [
        ""statuses_connectivity_code"",
        ""statuses_immobilization_code"",
        ""statuses_engine_code"",
        ""statuses_transit_code""
      ]
    },
    ""description"": ""Derived from status family codes using conditional priority evaluation""
  }
]",string,,"Family name of the highest-priority status family selected for top_status. 
Used to identify which status family (connectivity, immobilization, engine, or transit) currently has priority based on conditional priority rules.",top_status.family,calculated,"""""""""transit""""""""",,"Family name of highest-priority compatible status family. 
Evaluate status families in priority order: 
(1) Connectivity if compatible and code = ""offline"", 
(2) Immobilization if compatible and code = ""immobilized"", 
(3) Engine if compatible and code = ""running"", 
(4) Transit if compatible, 
(5) Connectivity fallback (code = ""online""). 
Return the family name (connectivity/immobilization/engine/transit) of the selected status family.",,,inactive,simple_value,,1.0.0,,
top_status_code,status,"Calculated: derive from statuses.connectivity.code, statuses.immobilization.code, statuses.engine.code, and statuses.transit.code using derive_top_status_code function. Evaluates status families in conditional priority order: (1) Connectivity if compatible and code = ""offline"", (2) Immobilization if compatible and code = ""immobilized"", (3) Engine if compatible and code = ""running"", (4) Transit if compatible, (5) Connectivity fallback (code = ""online""). Returns the code value from the selected status family (e.g., ""offline"", ""immobilized"", ""running"", ""in_transit"", ""parked"", ""online""). Backend must check asset type/subtype compatibility for each status family before evaluation.

Pseudo code:
if (connectivity.compatible && connectivity.code === ""offline"") {
  return connectivity.code
} else if (immobilization.compatible && immobilization.code === ""immobilized"") {
  return immobilization.code
} else if (engine.compatible && engine.code === ""running"") {
  return engine.code
} else if (transit.compatible) {
  return transit.code
} else {
  return connectivity.code  // fallback (""online"")
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""derive_top_status_code"",
    ""parameters"": {
      ""fleeti"": [
        ""statuses_connectivity_code"",
        ""statuses_immobilization_code"",
        ""statuses_engine_code"",
        ""statuses_transit_code""
      ]
    },
    ""description"": ""Derived from status family codes using conditional priority evaluation""
  }
]",string,,"Status code from the highest-priority status family selected for top_status. 
Represents the actual status value (e.g., ""offline"", ""immobilized"", ""running"", ""in_transit"", ""parked"", ""online"") from the prioritized status family.",top_status.code,calculated,"""""""""in_transit""""""""",,"Code from highest-priority compatible status family. 
Evaluate status families in priority order: 
(1) Connectivity if compatible and code = ""offline"", 
(2) Immobilization if compatible and code = ""immobilized"", 
(3) Engine if compatible and code = ""running"", 
(4) Transit if compatible, 
(5) Connectivity fallback (code = ""online""). 
Return the code value from the selected status family.",,,inactive,simple_value,,1.0.0,,
top_status_last_changed_at,status,"Calculated: derive from top_status_code using derive_top_status_last_changed_at function. Updates when top_status.code changes (not on every packet). Backend compares current top_status.code with previous value. If different, update timestamp to current ISO8601 UTC time. If same, keep previous timestamp unchanged. Used to calculate duration of current top status state (e.g., ""immobilized for 2 hours"", ""engine running since 10:30""). Enables timeline features and status duration calculations.

Pseudo code:
if (current_top_status_code !== previous_top_status_code) {
  top_status_last_changed_at = now()  // ISO8601 UTC timestamp
} else {
  top_status_last_changed_at = previous_top_status_last_changed_at  // keep unchanged
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""derive_top_status_last_changed_at"",
    ""parameters"": {
      ""fleeti"": [
        ""top_status_code""
      ]
    },
    ""description"": ""Derived from top_status_code, updates when code changes""
  }
]",date,,"ISO8601 timestamp when top_status.code last changed. 
Used to calculate duration of current top status state (e.g., ""immobilized for 2 hours"", ""engine running since 10:30""). 
Enables timeline features and status duration calculations.",top_status.last_changed_at,calculated,"""""""""2025-01-18T14:30:45Z""""""""",,"Updates when top_status.code changes (not on every packet). 
Backend compares current top_status.code with previous value. 
If different, update timestamp to current ISO8601 UTC time. 
If same, keep previous timestamp unchanged.",,,inactive,simple_value,,1.0.0,,
statuses_connectivity_code,status,"Calculated: derive from last_updated_at, asset_type, and asset_subtype using derive_statuses_connectivity_code function. Determines online/offline status based on time threshold: Vehicles, Equipment, and Phones use 24h threshold; Coldroom Sites use 1h threshold. Check asset type and subtype: if asset_type === Site (30) AND asset_subtype === Coldroom (10), use 1h threshold; otherwise use 24h threshold. Compare root-level last_updated_at (derived from msg_time) with current time. If difference < threshold ? ""online"", else ? ""offline"". Connectivity is based on the root-level last_updated_at timestamp (derived from msg_time), not GPS location updates.

Pseudo code:
threshold = (asset_type === Site && asset_subtype === Coldroom) ? 1 : 24  // hours
time_diff = current_time - last_updated_at
if (time_diff < threshold) {
  return ""online""
} else {
  return ""offline""
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""derive_statuses_connectivity_code"",
    ""parameters"": {
      ""fleeti"": [
        ""last_updated_at"",
        ""asset_type"",
        ""asset_subtype""
      ]
    },
    ""description"": ""Derived from last_updated_at, asset_type, and asset_subtype using time threshold logic""
  }
]",string,,"Connectivity status code: ""online"" or ""offline"" based on last_updated_at threshold. Indicates whether the asset has recently communicated with the Fleeti backend. Vehicles, Equipment, and Phones use 24h threshold; Coldroom Sites use 1h threshold.",statuses.connectivity.code,calculated,"""""""""online""""""""",,"online if last_updated_at < 24h, offline if ? 24h for vehicles/equipment/phones; 
1h threshold for coldroom sites. 
Check asset subtype: if Site.Coldroom, use 1h threshold; otherwise use 24h threshold. 
Compare root-level last_updated_at (derived from msg_time) with current time. 
If difference < threshold ? ""online"", else ? ""offline"".",,,inactive,simple_value,,1.0.0,,
statuses_connectivity_compatible,status,"Calculated: derive from asset_type and asset_subtype using derive_statuses_connectivity_compatible function. Check asset type/subtype against compatibility matrix (Connectivity: all types). Connectivity status is compatible with all asset types and subtypes. Return true for all assets. Connectivity applies to all asset types (Vehicles, Equipment, Sites, Phones) regardless of subtype.

Pseudo code:
// Connectivity is compatible with all asset types
return true","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""derive_statuses_connectivity_compatible"",
    ""parameters"": {
      ""fleeti"": [
        ""asset_type"",
        ""asset_subtype""
      ]
    },
    ""description"": ""Derived from asset_type and asset_subtype, always returns true for connectivity""
  }
]",string,,"Indicates if Connectivity status family is compatible with this asset type/subtype. 
Connectivity applies to all asset types (Vehicles, Equipment, Sites, Phones) regardless of subtype. 
Always true.",statuses.connectivity.compatible,calculated,"""""""""true""""""""",,"Check asset type/subtype against compatibility matrix (Connectivity: all types). 
Connectivity status is compatible with all asset types and subtypes. 
Return true for all assets.",,,inactive,simple_value,,1.0.0,,
statuses_connectivity_last_changed_at,status,"Calculated: derive from statuses_connectivity_code using derive_statuses_connectivity_last_changed_at function. Updates when status family code changes (not on every packet). Backend compares current statuses_connectivity_code with previous value. If different, update timestamp to current ISO8601 UTC time. If same, keep previous timestamp unchanged. Used to calculate duration of current connectivity status (e.g., ""offline for 2h"", ""online since yesterday""). Enables connectivity duration tracking and timeline features.

Pseudo code:
if (current_statuses_connectivity_code !== previous_statuses_connectivity_code) {
  statuses_connectivity_last_changed_at = now()  // ISO8601 UTC timestamp
} else {
  statuses_connectivity_last_changed_at = previous_statuses_connectivity_last_changed_at  // keep unchanged
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""derive_statuses_connectivity_last_changed_at"",
    ""parameters"": {
      ""fleeti"": [
        ""statuses_connectivity_code""
      ]
    },
    ""description"": ""Derived from statuses_connectivity_code, updates when code changes""
  }
]",date,,"ISO8601 timestamp when connectivity status code last changed. 
Used to calculate duration of current connectivity status (e.g., ""offline for 2h"", ""online since yesterday""). 
Enables connectivity duration tracking and timeline features.",statuses.connectivity.last_changed_at,calculated,"""""""""2025-01-18T14:30:45Z""""""""",,"Updates when status family code changes (not on every packet). 
Backend compares current statuses_connectivity_code with previous value. 
If different, update timestamp to current ISO8601 UTC time. 
If same, keep previous timestamp unchanged.",,,inactive,simple_value,,1.0.0,,
statuses_immobilization_code,status,"Calculated: derive from statuses_immobilization_compatible, asset_installation_immobilizer_output_number, outputs_individual_output_1, outputs_individual_output_2, and outputs_individual_output_3 using derive_statuses_immobilization_code function. Prerequisites: Check statuses_immobilization_compatible (must be true). If false, return null (immobilization not applicable). Read immobilizer output number from asset.installation.immobilizer_output_number (default to 1 if not specified). Read digital output state from the corresponding individual output field: outputs_individual_output_1 (if output_number = 1), outputs_individual_output_2 (if output_number = 2), or outputs_individual_output_3 (if output_number = 3). Status determination: If output state = 1 ? ""immobilized"". If output state = 0 ? ""free"". If immobilization command sent via REST API ? ""immobilizing"" (persists until output changes to 1 or timeout, managed by backend command tracking). If release command sent ? ""releasing"" (persists until output changes to 0 or timeout, managed by backend command tracking).

Pseudo code:
if (!statuses_immobilization_compatible) {
  return null  // Immobilization not applicable
}
output_number = asset_installation_immobilizer_output_number || 1  // default to 1
output_state = null
if (output_number === 1) {
  output_state = outputs_individual_output_1
} else if (output_number === 2) {
  output_state = outputs_individual_output_2
} else if (output_number === 3) {
  output_state = outputs_individual_output_3
}
if (isImmobilizingCommandActive()) {
  return ""immobilizing""
} else if (isReleasingCommandActive()) {
  return ""releasing""
} else if (output_state === 1) {
  return ""immobilized""
} else if (output_state === 0) {
  return ""free""
} else {
  return null  // output state unavailable
}",,string,,"Immobilization status code: ""immobilized"", ""free"", ""immobilizing"", or ""releasing"" based on digital output state and command tracking. 
Indicates whether the vehicle/equipment is currently immobilized (locked), free (unlocked), or in a transition state (immobilizing/releasing) managed by backend command tracking.",statuses.immobilization.code,calculated,"""""""""free""""""""",,,,,inactive,simple_value,,1.0.0,,
statuses_immobilization_compatible,status,"Calculated: derive from asset_type and asset_accessories using derive_statuses_immobilization_compatible function. Check asset type/subtype against compatibility matrix (Immobilization: Vehicles and Equipment only). Asset must have asset_type = Vehicle (10) OR Equipment (20). Asset must have immobilizer accessory installed (asset.accessories contains type_code=""immobilizer""). Return true if both conditions are met, false otherwise.

Pseudo code:
if (asset_type === Vehicle || asset_type === Equipment) {
  if (hasImmobilizerAccessory(asset_accessories)) {
    return true
  }
}
return false",,string,,,statuses.immobilization.compatible,calculated,"""""""""true""""""""",,,,,inactive,simple_value,,1.0.0,,
statuses_immobilization_last_changed_at,status,"Calculated: derive from statuses_immobilization_code using derive_statuses_immobilization_last_changed_at function. Updates when status family code changes (not on every packet). Backend compares current statuses_immobilization_code with previous value. If different, update timestamp to current ISO8601 UTC time. If same, keep previous timestamp unchanged. Used to calculate duration of current immobilization status (e.g., ""immobilized for 2h"", ""free since yesterday""). Enables immobilization duration tracking and timeline features.

Pseudo code:
if (current_statuses_immobilization_code !== previous_statuses_immobilization_code) {
  statuses_immobilization_last_changed_at = now()  // ISO8601 UTC timestamp
} else {
  statuses_immobilization_last_changed_at = previous_statuses_immobilization_last_changed_at  // keep unchanged
}",,date,,,statuses.immobilization.last_changed_at,calculated,"""""""""2025-01-18T14:30:45Z""""""""",,,,,inactive,simple_value,,1.0.0,,
statuses_engine_code,status,,,string,,,statuses.engine.code,calculated,"""""""""running""""""""",,,,,inactive,simple_value,,1.0.0,,
statuses_engine_compatible,status,,,string,,,statuses.engine.compatible,calculated,"""""""""true""""""""",,,,,inactive,simple_value,,1.0.0,,
statuses_engine_last_changed_at,status,,,date,,,statuses.engine.last_changed_at,calculated,"""""""""2025-01-18T14:30:45Z""""""""",,,,,inactive,simple_value,,1.0.0,,
statuses_transit_code,status,,,string,,,statuses.transit.code,calculated,"""""""""in_transit""""""""",,,,,inactive,simple_value,,1.0.0,,
statuses_transit_compatible,status,,,string,,,statuses.transit.compatible,calculated,"""""""""true""""""""",,,,,inactive,simple_value,,1.0.0,,
statuses_transit_last_changed_at,status,,,date,,,statuses.transit.last_changed_at,calculated,"""""""""2025-01-18T14:30:45Z""""""""",,,,,inactive,simple_value,,1.0.0,,
geofences,status,,,array,,,geofences[],,,,,,,inactive,array,,1.0.0,,
geofences_geofence_id,status,,,string,,,geofences.geofence_id,,"""""""""15""""""""",,,,,inactive,simple_value,,1.0.0,,
geofences_geofence_name,status,,,string,,,geofences.geofence_name,,"""""""""Service Area""""""""",,,,,inactive,simple_value,,1.0.0,,
location,location,,,object,,,location,,"""""""{""latitude"": ""decimal degrees (-90 to 90)"", ""longitude"": ""decimal degrees (-180 to 180)"", ""altitude"": ""meters above sea level"", ""heading"": ""degrees (0-359, 0=North)"", ""cardinal_direction"": ""string (N, NE, E, SE, S, SW, W, NW)"", ""geocoded_address"": ""string"", ""last_changed_at"": ""ISO8601"", ""precision"": {""hdop"": ""decimal (-1 to 20, -1=unknown)"", ""pdop"": ""decimal"", ""fix_quality"": ""integer (0=no fix, 1=fix)"", ""satellites"": ""integer (0-32)""}}""""""",,,,,inactive,nested_object,,1.0.0,,
connectivity,connectivity,,,object,,,connectivity,,"""""""{""signal_level"": ""integer (0-31, 99=unknown)"", ""operator"": ""string or integer code"", ""last_updated_at"": ""ISO"", ""data_mode"": ""integer (0-255)"", ""cell"": {""id"": ""integer (0-65535)"", ""lac"": ""integer (0-65535)""}, ""sim"": {""iccid"": [""string""]}}""""""",,,,,inactive,nested_object,,1.0.0,,
motion,motion,,,object,,,motion,,"""""""{""last_updated_at"": ""ISO"", ""speed"": {""value"": ""number"", ""unit"": ""km/h""}, ""is_moving"": {""value"": ""boolean"", ""last_changed_at"": ""ISO8601""}, ""instant_movement"": ""boolean"", ""accelerometer"": {""x"": ""number (mG)"", ""y"": ""number (mG)"", ""z"": ""number (mG)""}}""""""",,,,,inactive,nested_object,,1.0.0,,
last_updated_at,power,,,date,,,last_updated_at,,"""""""""2025-01-18T14:30:45Z""""""""",,,,,inactive,simple_value,,1.0.0,,
ignition_value,power,,,boolean,,,ignition.value,,"""""""""boolean""""""""",,,,,inactive,simple_value,,1.0.0,,
ignition_last_changed_at,power,,,string,,,ignition.last_changed_at,,"""""""""2025-01-18T14:30:45Z""""""""",,,,,inactive,simple_value,,1.0.0,,
inputs_individual_input_1,io,"Prioritized: extract bit 0 from inputs bitmask at root level using extract_bit_from_bitmask function (priority 1), then Navixy avl_io_1 (path: params.avl_io_1, priority 2) - Digital Input 1 state. Values: 0 = low/inactive, 1 = high/active. Semantic meaning (e.g., ignition, door sensor) is defined in asset.installation.* metadata. Used to compute canonical fields like power.ignition.

Pseudo code:
if (inputs bitmask is available) {
  io_input_1 = extractBit(inputs, 0)  // extract bit 0 from Digital Inputs Bitmask at root level
} else if (avl_io_1 is available) {
  io_input_1 = avl_io_1  // fallback: direct mapping from params.avl_io_1
} else {
  io_input_1 = null
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""extract_bit_from_bitmask"",
    ""parameters"": {
      ""provider"": {
        ""navixy"": ""inputs""
      }
    },
    ""description"": ""Extract bit 0 from Digital Inputs Bitmask at root level""
  },
  {
    ""priority"": 2,
    ""type"": ""direct"",
    ""source_type"": ""provider"",
    ""provider"": ""navixy"",
    ""field"": ""avl_io_1"",
    ""path"": ""params.avl_io_1"",
    ""description"": ""Digital Input 1 from Navixy (fallback)""
  }
]",boolean,,Digital Input 1,inputs.individual.input_1,,"""""""""boolean""""""""",,"Navixy: avl_io_1 (Digital Input 1), inputs (Digital Inputs Bitmask, bit 0)	Digital input 1 state. Values: 0 = low/inactive, 1 = high/active. Semantic meaning (e.g., ignition, door sensor) is defined in asset.installation.* metadata. Used to compute canonical fields like power.ignition. If only bitmask is available, transformation pipeline extracts bit 0.So basically, we take AVLIO1 as a priority input direct mapping, and we take inputs from root level packet plug. We have a bit mask, and we take the bit 0. ",,,inactive,simple_value,,1.0.0,,
inputs_individual_input_2,io,"Prioritized: extract bit 1 from inputs bitmask at root level using extract_bit_from_bitmask function (priority 1), then Navixy avl_io_2 (path: params.avl_io_2, priority 2) - Digital Input 2 state. Values: 0 = low/inactive, 1 = high/active. Semantic meaning (e.g., door sensor, alarm) is defined in asset.installation.* metadata. Used to compute canonical fields.

Pseudo code:
if (inputs bitmask is available) {
  io_input_2 = extractBit(inputs, 1)  // extract bit 1 from Digital Inputs Bitmask at root level
} else if (avl_io_2 is available) {
  io_input_2 = avl_io_2  // fallback: direct mapping from params.avl_io_2
} else {
  io_input_2 = null
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""extract_bit_from_bitmask"",
    ""parameters"": {
      ""provider"": {
        ""navixy"": ""inputs""
      }
    },
    ""description"": ""Extract bit 1 from Digital Inputs Bitmask at root level""
  },
  {
    ""priority"": 2,
    ""type"": ""direct"",
    ""source_type"": ""provider"",
    ""provider"": ""navixy"",
    ""field"": ""avl_io_2"",
    ""path"": ""params.avl_io_2"",
    ""description"": ""Digital Input 2 from Navixy (fallback)""
  }
]",boolean,,Digital Input 2,inputs.individual.input_2,,"""""""""boolean""""""""",,,,,inactive,simple_value,,1.0.0,,
inputs_individual_input_3,io,"Prioritized: extract bit 2 from inputs bitmask at root level using extract_bit_from_bitmask function (priority 1), then Navixy avl_io_3 (path: params.avl_io_3, priority 2) - Digital Input 3 state. Values: 0 = low/inactive, 1 = high/active. Semantic meaning (e.g., door sensor, alarm) is defined in asset.installation.* metadata. Used to compute canonical fields.

Pseudo code:
if (inputs bitmask is available) {
  io_input_3 = extractBit(inputs, 2)  // extract bit 2 from Digital Inputs Bitmask at root level
} else if (avl_io_3 is available) {
  io_input_3 = avl_io_3  // fallback: direct mapping from params.avl_io_3
} else {
  io_input_3 = null
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""extract_bit_from_bitmask"",
    ""parameters"": {
      ""provider"": {
        ""navixy"": ""inputs""
      }
    },
    ""description"": ""Extract bit 2 from Digital Inputs Bitmask at root level""
  },
  {
    ""priority"": 2,
    ""type"": ""direct"",
    ""source_type"": ""provider"",
    ""provider"": ""navixy"",
    ""field"": ""avl_io_3"",
    ""path"": ""params.avl_io_3"",
    ""description"": ""Digital Input 3 from Navixy (fallback)""
  }
]",boolean,,Digital Input 3,inputs.individual.input_3,,"""""""""boolean""""""""",,,,,inactive,simple_value,,1.0.0,,
inputs_individual_input_4,io,"Prioritized: extract bit 3 from inputs bitmask at root level using extract_bit_from_bitmask function (priority 1), then Navixy avl_io_4 (path: params.avl_io_4, priority 2) - Digital Input 4 state (also functions as pulse counter). Values: 0 = low/inactive, 1 = high/active. Pulse count resets when records are saved. Semantic meaning (e.g., door sensor, alarm) is defined in asset.installation.* metadata. Used to compute canonical fields.

Pseudo code:
if (inputs bitmask is available) {
  io_input_4 = extractBit(inputs, 3)  // extract bit 3 from Digital Inputs Bitmask at root level
} else if (avl_io_4 is available) {
  io_input_4 = avl_io_4  // fallback: direct mapping from params.avl_io_4
} else {
  io_input_4 = null
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""extract_bit_from_bitmask"",
    ""parameters"": {
      ""provider"": {
        ""navixy"": ""inputs""
      }
    },
    ""description"": ""Extract bit 3 from Digital Inputs Bitmask at root level""
  },
  {
    ""priority"": 2,
    ""type"": ""direct"",
    ""source_type"": ""provider"",
    ""provider"": ""navixy"",
    ""field"": ""avl_io_4"",
    ""path"": ""params.avl_io_4"",
    ""description"": ""Digital Input 4 from Navixy (fallback)""
  }
]",boolean,,Digital Input 4,inputs.individual.input_4,,"""""""""boolean""""""""",,,,,inactive,simple_value,,1.0.0,,
outputs_individual_output_1,io,"Prioritized: extract bit 0 from outputs bitmask at root level using extract_bit_from_bitmask function (priority 1), then Navixy avl_io_179 (path: params.avl_io_179, priority 2) - Digital Output 1 state. Values: 0 = inactive, 1 = active. Semantic meaning (e.g., immobilizer relay) is defined in asset.installation.* metadata. Used for immobilization control and status computation.

Pseudo code:
if (outputs bitmask is available) {
  io_output_1 = extractBit(outputs, 0)  // extract bit 0 from Output Status Bitmask at root level
} else if (avl_io_179 is available) {
  io_output_1 = avl_io_179  // fallback: direct mapping from params.avl_io_179
} else {
  io_output_1 = null
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""extract_bit_from_bitmask"",
    ""parameters"": {
      ""provider"": {
        ""navixy"": ""outputs""
      }
    },
    ""description"": ""Extract bit 0 from Output Status Bitmask at root level""
  },
  {
    ""priority"": 2,
    ""type"": ""direct"",
    ""source_type"": ""provider"",
    ""provider"": ""navixy"",
    ""field"": ""avl_io_179"",
    ""path"": ""params.avl_io_179"",
    ""description"": ""Digital Output 1 from Navixy (fallback)""
  }
]",boolean,,Digital Output 1,outputs.individual.output_1,,"""""""""boolean""""""""",,"We should use AVL inside the Params object, or in priority to use outputs at the root level of the packet. ",,,inactive,simple_value,,1.0.0,,
outputs_individual_output_2,io,"Prioritized: extract bit 1 from outputs bitmask at root level using extract_bit_from_bitmask function (priority 1), then Navixy avl_io_180 (path: params.avl_io_180, priority 2) - Digital Output 2 state. Values: 0 = inactive, 1 = active. Semantic meaning (e.g., immobilizer relay) is defined in asset.installation.* metadata. Used for immobilization control and status computation.

Pseudo code:
if (outputs bitmask is available) {
  io_output_2 = extractBit(outputs, 1)  // extract bit 1 from Output Status Bitmask at root level
} else if (avl_io_180 is available) {
  io_output_2 = avl_io_180  // fallback: direct mapping from params.avl_io_180
} else {
  io_output_2 = null
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""extract_bit_from_bitmask"",
    ""parameters"": {
      ""provider"": {
        ""navixy"": ""outputs""
      }
    },
    ""description"": ""Extract bit 1 from Output Status Bitmask at root level""
  },
  {
    ""priority"": 2,
    ""type"": ""direct"",
    ""source_type"": ""provider"",
    ""provider"": ""navixy"",
    ""field"": ""avl_io_180"",
    ""path"": ""params.avl_io_180"",
    ""description"": ""Digital Output 2 from Navixy (fallback)""
  }
]",boolean,,Digital Output 2,outputs.individual.output_2,,"""""""""boolean""""""""",,"We should use AVL inside the Params object, or in priority to use outputs at the root level of the packet. ",,,inactive,simple_value,,1.0.0,,
outputs_individual_output_3,io,"Prioritized: extract bit 2 from outputs bitmask at root level using extract_bit_from_bitmask function (priority 1), then Navixy avl_io_380 (path: params.avl_io_380, priority 2) - Digital Output 3 state. Values: 0 = inactive, 1 = active. Semantic meaning (e.g., immobilizer relay) is defined in asset.installation.* metadata. Used for immobilization control and status computation.

Pseudo code:
if (outputs bitmask is available) {
  io_output_3 = extractBit(outputs, 2)  // extract bit 2 from Output Status Bitmask at root level
} else if (avl_io_380 is available) {
  io_output_3 = avl_io_380  // fallback: direct mapping from params.avl_io_380
} else {
  io_output_3 = null
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""extract_bit_from_bitmask"",
    ""parameters"": {
      ""provider"": {
        ""navixy"": ""outputs""
      }
    },
    ""description"": ""Extract bit 2 from Output Status Bitmask at root level""
  },
  {
    ""priority"": 2,
    ""type"": ""direct"",
    ""source_type"": ""provider"",
    ""provider"": ""navixy"",
    ""field"": ""avl_io_380"",
    ""path"": ""params.avl_io_380"",
    ""description"": ""Digital Output 3 from Navixy (fallback)""
  }
]",boolean,,Digital Output 3,outputs.individual.output_3,,"""""""""boolean""""""""",,"We should use AVL inside the Params object, or in priority to use outputs at the root level of the packet. ",,,inactive,simple_value,,1.0.0,,
