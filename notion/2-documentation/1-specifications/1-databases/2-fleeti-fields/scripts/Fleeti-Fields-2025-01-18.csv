Name,Category,Computation Approach,Computation Structure,Data Type,Dependencies,Description,Field Path,Field Type,Example,Mapping Fields (db),Notes,Priority,REST API Endpoints,Status,Structure Type,Unit,Version Added,WebSocket Contracts,ðŸ’½ Provider Field (db)
last_updated_at,metadata,(msg_time),,date,,"Timestamp of when the telemetry record was originally created on the GPS tracker device, before transmission to the provider.",last_updated_at,direct,"""""""""2025-01-18T14:30:45Z""""""""",,,,,inactive,simple_value,,1.0.0,,
top_status_family,status,"Calculated: derive from statuses.connectivity.code, statuses.immobilization.code, statuses.engine.code, and statuses.transit.code using derive_top_status_family function. Evaluates status families in conditional priority order: (1) Connectivity if compatible and code = ""offline"", (2) Immobilization if compatible and code = ""immobilized"", (3) Engine if compatible and code = ""running"", (4) Transit if compatible, (5) Connectivity fallback (code = ""online""). Returns the family name (connectivity/immobilization/engine/transit) of the selected status family. Backend must check asset type/subtype compatibility for each status family before evaluation.

Pseudo code:
if (connectivity.compatible && connectivity.code === ""offline"") {
  return ""connectivity""
} else if (immobilization.compatible && immobilization.code === ""immobilized"") {
  return ""immobilization""
} else if (engine.compatible && engine.code === ""running"") {
  return ""engine""
} else if (transit.compatible) {
  return ""transit""
} else {
  return ""connectivity""  // fallback (online)
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""derive_top_status_family"",
    ""parameters"": {
      ""fleeti"": [
        ""statuses_connectivity_code"",
        ""statuses_immobilization_code"",
        ""statuses_engine_code"",
        ""statuses_transit_code""
      ]
    },
    ""description"": ""Derived from status family codes using conditional priority evaluation""
  }
]",string,,"Family name of the highest-priority status family selected for top_status. 
Used to identify which status family (connectivity, immobilization, engine, or transit) currently has priority based on conditional priority rules.",top_status.family,calculated,"""""""""transit""""""""",,"Family name of highest-priority compatible status family. 
Evaluate status families in priority order: 
(1) Connectivity if compatible and code = ""offline"", 
(2) Immobilization if compatible and code = ""immobilized"", 
(3) Engine if compatible and code = ""running"", 
(4) Transit if compatible, 
(5) Connectivity fallback (code = ""online""). 
Return the family name (connectivity/immobilization/engine/transit) of the selected status family.",,,inactive,simple_value,,1.0.0,,
top_status_code,status,"Calculated: derive from statuses.connectivity.code, statuses.immobilization.code, statuses.engine.code, and statuses.transit.code using derive_top_status_code function. Evaluates status families in conditional priority order: (1) Connectivity if compatible and code = ""offline"", (2) Immobilization if compatible and code = ""immobilized"", (3) Engine if compatible and code = ""running"", (4) Transit if compatible, (5) Connectivity fallback (code = ""online""). Returns the code value from the selected status family (e.g., ""offline"", ""immobilized"", ""running"", ""in_transit"", ""parked"", ""online""). Backend must check asset type/subtype compatibility for each status family before evaluation.

Pseudo code:
if (connectivity.compatible && connectivity.code === ""offline"") {
  return connectivity.code
} else if (immobilization.compatible && immobilization.code === ""immobilized"") {
  return immobilization.code
} else if (engine.compatible && engine.code === ""running"") {
  return engine.code
} else if (transit.compatible) {
  return transit.code
} else {
  return connectivity.code  // fallback (""online"")
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""derive_top_status_code"",
    ""parameters"": {
      ""fleeti"": [
        ""statuses_connectivity_code"",
        ""statuses_immobilization_code"",
        ""statuses_engine_code"",
        ""statuses_transit_code""
      ]
    },
    ""description"": ""Derived from status family codes using conditional priority evaluation""
  }
]",string,,"Status code from the highest-priority status family selected for top_status. 
Represents the actual status value (e.g., ""offline"", ""immobilized"", ""running"", ""in_transit"", ""parked"", ""online"") from the prioritized status family.",top_status.code,calculated,"""""""""in_transit""""""""",,"Code from highest-priority compatible status family. 
Evaluate status families in priority order: 
(1) Connectivity if compatible and code = ""offline"", 
(2) Immobilization if compatible and code = ""immobilized"", 
(3) Engine if compatible and code = ""running"", 
(4) Transit if compatible, 
(5) Connectivity fallback (code = ""online""). 
Return the code value from the selected status family.",,,inactive,simple_value,,1.0.0,,
top_status_last_changed_at,status,"Calculated: derive from top_status_code using derive_top_status_last_changed_at function. Updates when top_status.code changes (not on every packet). Backend compares current top_status.code with previous value. If different, update timestamp to current ISO8601 UTC time. If same, keep previous timestamp unchanged. Used to calculate duration of current top status state (e.g., ""immobilized for 2 hours"", ""engine running since 10:30""). Enables timeline features and status duration calculations.

Pseudo code:
if (current_top_status_code !== previous_top_status_code) {
  top_status_last_changed_at = now()  // ISO8601 UTC timestamp
} else {
  top_status_last_changed_at = previous_top_status_last_changed_at  // keep unchanged
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""derive_top_status_last_changed_at"",
    ""parameters"": {
      ""fleeti"": [
        ""top_status_code""
      ]
    },
    ""description"": ""Derived from top_status_code, updates when code changes""
  }
]",date,,"ISO8601 timestamp when top_status.code last changed. 
Used to calculate duration of current top status state (e.g., ""immobilized for 2 hours"", ""engine running since 10:30""). 
Enables timeline features and status duration calculations.",top_status.last_changed_at,calculated,"""""""""2025-01-18T14:30:45Z""""""""",,"Updates when top_status.code changes (not on every packet). 
Backend compares current top_status.code with previous value. 
If different, update timestamp to current ISO8601 UTC time. 
If same, keep previous timestamp unchanged.",,,inactive,simple_value,,1.0.0,,
statuses_connectivity_code,status,"Calculated: derive from last_updated_at, asset_type, and asset_subtype using derive_statuses_connectivity_code function. Determines online/offline status based on time threshold: Vehicles, Equipment, and Phones use 24h threshold; Coldroom Sites use 1h threshold. Check asset type and subtype: if asset_type === Site (30) AND asset_subtype === Coldroom (10), use 1h threshold; otherwise use 24h threshold. Compare root-level last_updated_at (derived from msg_time) with current time. If difference < threshold ? ""online"", else ? ""offline"". Connectivity is based on the root-level last_updated_at timestamp (derived from msg_time), not GPS location updates.

Pseudo code:
threshold = (asset_type === Site && asset_subtype === Coldroom) ? 1 : 24  // hours
time_diff = current_time - last_updated_at
if (time_diff < threshold) {
  return ""online""
} else {
  return ""offline""
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""derive_statuses_connectivity_code"",
    ""parameters"": {
      ""fleeti"": [
        ""last_updated_at"",
        ""asset_type"",
        ""asset_subtype""
      ]
    },
    ""description"": ""Derived from last_updated_at, asset_type, and asset_subtype using time threshold logic""
  }
]",string,,"Connectivity status code: ""online"" or ""offline"" based on last_updated_at threshold. Indicates whether the asset has recently communicated with the Fleeti backend. Vehicles, Equipment, and Phones use 24h threshold; Coldroom Sites use 1h threshold.",statuses.connectivity.code,calculated,"""""""""online""""""""",,"online if last_updated_at < 24h, offline if ? 24h for vehicles/equipment/phones; 
1h threshold for coldroom sites. 
Check asset subtype: if Site.Coldroom, use 1h threshold; otherwise use 24h threshold. 
Compare root-level last_updated_at (derived from msg_time) with current time. 
If difference < threshold ? ""online"", else ? ""offline"".",,,inactive,simple_value,,1.0.0,,
statuses_connectivity_compatible,status,"Calculated: derive from asset_type and asset_subtype using derive_statuses_connectivity_compatible function. Check asset type/subtype against compatibility matrix (Connectivity: all types). Connectivity status is compatible with all asset types and subtypes. Return true for all assets. Connectivity applies to all asset types (Vehicles, Equipment, Sites, Phones) regardless of subtype.

Pseudo code:
// Connectivity is compatible with all asset types
return true","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""derive_statuses_connectivity_compatible"",
    ""parameters"": {
      ""fleeti"": [
        ""asset_type"",
        ""asset_subtype""
      ]
    },
    ""description"": ""Derived from asset_type and asset_subtype, always returns true for connectivity""
  }
]",string,,"Indicates if Connectivity status family is compatible with this asset type/subtype. 
Connectivity applies to all asset types (Vehicles, Equipment, Sites, Phones) regardless of subtype. 
Always true.",statuses.connectivity.compatible,calculated,"""""""""true""""""""",,"Check asset type/subtype against compatibility matrix (Connectivity: all types). 
Connectivity status is compatible with all asset types and subtypes. 
Return true for all assets.",,,inactive,simple_value,,1.0.0,,
statuses_connectivity_last_changed_at,status,"Calculated: derive from statuses_connectivity_code using derive_statuses_connectivity_last_changed_at function. Updates when status family code changes (not on every packet). Backend compares current statuses_connectivity_code with previous value. If different, update timestamp to current ISO8601 UTC time. If same, keep previous timestamp unchanged. Used to calculate duration of current connectivity status (e.g., ""offline for 2h"", ""online since yesterday""). Enables connectivity duration tracking and timeline features.

Pseudo code:
if (current_statuses_connectivity_code !== previous_statuses_connectivity_code) {
  statuses_connectivity_last_changed_at = now()  // ISO8601 UTC timestamp
} else {
  statuses_connectivity_last_changed_at = previous_statuses_connectivity_last_changed_at  // keep unchanged
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""derive_statuses_connectivity_last_changed_at"",
    ""parameters"": {
      ""fleeti"": [
        ""statuses_connectivity_code""
      ]
    },
    ""description"": ""Derived from statuses_connectivity_code, updates when code changes""
  }
]",date,,"ISO8601 timestamp when connectivity status code last changed. 
Used to calculate duration of current connectivity status (e.g., ""offline for 2h"", ""online since yesterday""). 
Enables connectivity duration tracking and timeline features.",statuses.connectivity.last_changed_at,calculated,"""""""""2025-01-18T14:30:45Z""""""""",,"Updates when status family code changes (not on every packet). 
Backend compares current statuses_connectivity_code with previous value. 
If different, update timestamp to current ISO8601 UTC time. 
If same, keep previous timestamp unchanged.",,,inactive,simple_value,,1.0.0,,
statuses_immobilization_code,status,"Calculated: derive from statuses_immobilization_compatible, asset_installation_immobilizer_output_number, outputs_individual_output_1, outputs_individual_output_2, and outputs_individual_output_3 using derive_statuses_immobilization_code function. Prerequisites: Check statuses_immobilization_compatible (must be true). If false, return null (immobilization not applicable). Read immobilizer output number from asset.installation.immobilizer_output_number (default to 1 if not specified). Read digital output state from the corresponding individual output field: outputs_individual_output_1 (if output_number = 1), outputs_individual_output_2 (if output_number = 2), or outputs_individual_output_3 (if output_number = 3). Status determination: If output state = 1 ? ""immobilized"". If output state = 0 ? ""free"". If immobilization command sent via REST API ? ""immobilizing"" (persists until output changes to 1 or timeout, managed by backend command tracking). If release command sent ? ""releasing"" (persists until output changes to 0 or timeout, managed by backend command tracking).

Pseudo code:
if (!statuses_immobilization_compatible) {
  return null  // Immobilization not applicable
}
output_number = asset_installation_immobilizer_output_number || 1  // default to 1
output_state = null
if (output_number === 1) {
  output_state = outputs_individual_output_1
} else if (output_number === 2) {
  output_state = outputs_individual_output_2
} else if (output_number === 3) {
  output_state = outputs_individual_output_3
}
if (isImmobilizingCommandActive()) {
  return ""immobilizing""
} else if (isReleasingCommandActive()) {
  return ""releasing""
} else if (output_state === 1) {
  return ""immobilized""
} else if (output_state === 0) {
  return ""free""
} else {
  return null  // output state unavailable
}",,string,,"Immobilization status code: ""immobilized"", ""free"", ""immobilizing"", or ""releasing"" based on digital output state and command tracking. 
Indicates whether the vehicle/equipment is currently immobilized (locked), free (unlocked), or in a transition state (immobilizing/releasing) managed by backend command tracking.",statuses.immobilization.code,calculated,"""""""""free""""""""",,,,,inactive,simple_value,,1.0.0,,
statuses_immobilization_compatible,status,"Calculated: derive from asset_type and asset_accessories using derive_statuses_immobilization_compatible function. Check asset type/subtype against compatibility matrix (Immobilization: Vehicles and Equipment only). Asset must have asset_type = Vehicle (10) OR Equipment (20). Asset must have immobilizer accessory installed (asset.accessories contains type_code=""immobilizer""). Return true if both conditions are met, false otherwise.

Pseudo code:
if (asset_type === Vehicle || asset_type === Equipment) {
  if (hasImmobilizerAccessory(asset_accessories)) {
    return true
  }
}
return false",,string,,,statuses.immobilization.compatible,calculated,"""""""""true""""""""",,,,,inactive,simple_value,,1.0.0,,
statuses_immobilization_last_changed_at,status,"Calculated: derive from statuses_immobilization_code using derive_statuses_immobilization_last_changed_at function. Updates when status family code changes (not on every packet). Backend compares current statuses_immobilization_code with previous value. If different, update timestamp to current ISO8601 UTC time. If same, keep previous timestamp unchanged. Used to calculate duration of current immobilization status (e.g., ""immobilized for 2h"", ""free since yesterday""). Enables immobilization duration tracking and timeline features.

Pseudo code:
if (current_statuses_immobilization_code !== previous_statuses_immobilization_code) {
  statuses_immobilization_last_changed_at = now()  // ISO8601 UTC timestamp
} else {
  statuses_immobilization_last_changed_at = previous_statuses_immobilization_last_changed_at  // keep unchanged
}",,date,,,statuses.immobilization.last_changed_at,calculated,"""""""""2025-01-18T14:30:45Z""""""""",,,,,inactive,simple_value,,1.0.0,,
statuses_engine_code,status,"Calculated: derive from statuses_engine_compatible and ignition_value using derive_statuses_engine_code function. Prerequisites: Check statuses_engine_compatible (must be true). If false, return null (engine status not applicable). If true, check ignition state: If ignition_value = true (ON) ? ""running"". If ignition_value = false (OFF) ? ""standby"". If ignition_value is null or unavailable, return null. Engine status is based on ignition state for compatible assets. The ignition_value field already handles reading from the correct input based on installation metadata (ignition_input_number), with fallback to input 1 if metadata unavailable.

Pseudo code:
if (!statuses_engine_compatible) {
  return null  // Engine status not applicable
}
if (ignition_value === true) {
  return ""running""
} else if (ignition_value === false) {
  return ""standby""
} else {
  return null  // Ignition state unavailable
}","[{""priority"": 1, ""type"": ""calculated"", ""calculation_type"": ""function_reference"", ""function"": ""derive_statuses_engine_code"", ""parameters"": {""fleeti"": [""statuses_engine_compatible"", ""ignition_value""]}, ""description"": ""Derived from statuses_engine_compatible and ignition_value, determines running/standby status""}]",string,,,statuses.engine.code,calculated,"""""""""running""""""""",,"Calculated: derive from statuses_engine_compatible and ignition_value using derive_statuses_engine_code function. Prerequisites: Check statuses_engine_compatible (must be true). If false, return null (engine status not applicable). If true, check ignition state: If ignition_value = true (ON) ? ""running"". If ignition_value = false (OFF) ? ""standby"". If ignition_value is null or unavailable, return null. Engine status is based on ignition state for compatible assets. The ignition_value field already handles reading from the correct input based on installation metadata (ignition_input_number), with fallback to input 1 if metadata unavailable.",,,inactive,simple_value,,1.0.0,,
statuses_engine_compatible,status,"Calculated: derive from asset_type and asset_subtype using derive_statuses_engine_compatible function. Check asset type/subtype against compatibility matrix (Engine: Equipment.ElectricGenerator, Vehicle.Agricultural, Vehicle.Machine only). Equipment: Only Equipment.ElectricGenerator supports engine status. Vehicles: Only Vehicle.Agricultural and Vehicle.Machine support engine status. Sites: No (all subtypes). Phones: No (all subtypes). Return true if asset type/subtype is compatible, false otherwise.

Pseudo code:
if (asset_type === Equipment && asset_subtype === ElectricGenerator) {
  return true
} else if (asset_type === Vehicle && (asset_subtype === Agricultural || asset_subtype === Machine)) {
  return true
} else {
  return false
}","[{""priority"": 1, ""type"": ""calculated"", ""calculation_type"": ""function_reference"", ""function"": ""derive_statuses_engine_compatible"", ""parameters"": {""fleeti"": [""asset_type"", ""asset_subtype""]}, ""description"": ""Derived from asset_type and asset_subtype, checks compatibility matrix for engine status""}]",string,,,statuses.engine.compatible,calculated,"""""""""true""""""""",,"Calculated: derive from asset_type and asset_subtype using derive_statuses_engine_compatible function. Check asset type/subtype against compatibility matrix (Engine: Equipment.ElectricGenerator, Vehicle.Agricultural, Vehicle.Machine only). Equipment: Only Equipment.ElectricGenerator supports engine status. Vehicles: Only Vehicle.Agricultural and Vehicle.Machine support engine status. Sites: No (all subtypes). Phones: No (all subtypes). Return true if asset type/subtype is compatible, false otherwise.",,,inactive,simple_value,,1.0.0,,
statuses_engine_last_changed_at,status,"Calculated: derive from statuses_engine_code using derive_statuses_engine_last_changed_at function. Updates when status family code changes (not on every packet). Backend compares current statuses_engine_code with previous value. If different, update timestamp to current ISO8601 UTC time. If same, keep previous timestamp unchanged. Used to calculate duration of current engine status (e.g., ""running for 2h"", ""standby since yesterday""). Enables engine duration tracking and timeline features.

Pseudo code:
if (current_statuses_engine_code !== previous_statuses_engine_code) {
  statuses_engine_last_changed_at = now()  // ISO8601 UTC timestamp
} else {
  statuses_engine_last_changed_at = previous_statuses_engine_last_changed_at  // keep unchanged
}","[{""priority"": 1, ""type"": ""calculated"", ""calculation_type"": ""function_reference"", ""function"": ""derive_statuses_engine_last_changed_at"", ""parameters"": {""fleeti"": [""statuses_engine_code""]}, ""description"": ""Derived from statuses_engine_code, updates when engine status changes""}]",date,,,statuses.engine.last_changed_at,calculated,"""""""""2025-01-18T14:30:45Z""""""""",,"Calculated: Backend compares current statuses_engine_code with previous value. If different, update timestamp to current ISO8601 UTC time. If same, keep previous timestamp unchanged. Used to calculate duration of current engine status (e.g., ""running for 2h"", ""standby since yesterday""). Updates only when engine status changes (not on every packet).",,,inactive,simple_value,,1.0.0,,
statuses_transit_code,status,"Calculated: derive from statuses_transit_compatible, ignition_value, is_moving_value, and speed using derive_statuses_transit_code function. Prerequisites: Check statuses_transit_compatible (must be true). If false, return null (transit status not applicable). Uses state machine with ignition triggers and movement/speed conditions. Immediate transitions: Ignition OFF â†’ ON: â†’ ""in_transit"" (immediate). Ignition ON â†’ OFF: â†’ ""parked"" (immediate). Duration-based transitions: IN_TRANSIT â†’ PARKED: (movement = false OR speed = 0) for 3 minutes â†’ ""parked"". PARKED â†’ IN_TRANSIT: (movement = true OR speed > 0.5 km/h) â†’ ""in_transit"" (immediate). Initial state: If ignition = true OR (movement = true OR speed > 0.5 km/h) â†’ ""in_transit"". If (movement = false AND speed = 0) for 3 minutes â†’ ""parked"". Default â†’ ""in_transit"" (conservative). Speed threshold: 0.5 km/h (filters GPS drift). Parked detection duration: 3 minutes (180 seconds). Ignition state only used when true (ignition ON); false or null = unavailable. Backend must track current Transit Status to apply transition rules. If movement_status and speed are unavailable, maintain current status (no transition).

Pseudo code:
if (!statuses_transit_compatible) {
  return null  // Transit status not applicable
}
// Immediate ignition transitions
if (previous_ignition_value === false && ignition_value === true) {
  return ""in_transit""  // Ignition OFF â†’ ON
}
if (previous_ignition_value === true && ignition_value === false) {
  return ""parked""  // Ignition ON â†’ OFF
}
// State machine logic (requires backend state tracking)
current_state = getPreviousTransitStatus()  // Backend tracks state
if (current_state === ""in_transit"") {
  if ((is_moving_value === false || is_moving_value === 0) && (speed === null || speed === 0)) {
    if (durationInState >= 3 minutes) {
      return ""parked""
    }
  }
} else if (current_state === ""parked"") {
  if (is_moving_value === true || is_moving_value === 1 || (speed !== null && speed > 0.5)) {
    return ""in_transit""
  }
} else {
  // Initial state
  if (ignition_value === true || is_moving_value === true || (speed !== null && speed > 0.5)) {
    return ""in_transit""
  } else if ((is_moving_value === false || is_moving_value === 0) && (speed === null || speed === 0)) {
    if (durationInState >= 3 minutes) {
      return ""parked""
    }
  }
  return ""in_transit""  // Default conservative
}","[{""priority"": 1, ""type"": ""calculated"", ""calculation_type"": ""function_reference"", ""function"": ""derive_statuses_transit_code"", ""parameters"": {""fleeti"": [""statuses_transit_compatible"", ""ignition_value"", ""is_moving_value"", ""speed""]}, ""description"": ""Derived from statuses_transit_compatible, ignition_value, is_moving_value, and speed using state machine logic""}]",string,,,statuses.transit.code,calculated,"""""""""in_transit""""""""",,"Calculated: derive from statuses_transit_compatible, ignition_value, is_moving_value, and speed using derive_statuses_transit_code function. Prerequisites: Check statuses_transit_compatible (must be true). If false, return null (transit status not applicable). Uses state machine with ignition triggers and movement/speed conditions. Immediate transitions: Ignition OFF â†’ ON: â†’ ""in_transit"" (immediate). Ignition ON â†’ OFF: â†’ ""parked"" (immediate). Duration-based transitions: IN_TRANSIT â†’ PARKED: (movement = false OR speed = 0) for 3 minutes â†’ ""parked"". PARKED â†’ IN_TRANSIT: (movement = true OR speed > 0.5 km/h) â†’ ""in_transit"" (immediate). Initial state: If ignition = true OR (movement = true OR speed > 0.5 km/h) â†’ ""in_transit"". If (movement = false AND speed = 0) for 3 minutes â†’ ""parked"". Default â†’ ""in_transit"" (conservative). Speed threshold: 0.5 km/h (filters GPS drift). Parked detection duration: 3 minutes (180 seconds). Ignition state only used when true (ignition ON); false or null = unavailable. Backend must track current Transit Status to apply transition rules. If movement_status and speed are unavailable, maintain current status (no transition).",,,inactive,simple_value,,1.0.0,,
statuses_transit_compatible,status,"Calculated: derive from asset_type and asset_subtype using derive_statuses_transit_compatible function. Check asset type/subtype against compatibility matrix (Transit: Phone all subtypes, Equipment.Undefined, All Vehicle subtypes except excluded). Supported: Phone (all subtypes), Equipment.Undefined, All Vehicle subtypes (except those explicitly excluded). NOT supported: Site.Undefined, Site.Coldroom, Equipment.FuelTank, Equipment.ElectricGenerator. Return true if asset type/subtype is compatible, false otherwise.

Pseudo code:
if (asset_type === Site) {
  return false  // Sites not supported
} else if (asset_type === Phone) {
  return true  // All phone subtypes supported
} else if (asset_type === Equipment) {
  if (asset_subtype === Undefined) {
    return true
  } else {
    return false  // Equipment.FuelTank and Equipment.ElectricGenerator not supported
  }
} else if (asset_type === Vehicle) {
  return true  // All vehicle subtypes supported (except those explicitly excluded in matrix)
} else {
  return false
}","[{""priority"": 1, ""type"": ""calculated"", ""calculation_type"": ""function_reference"", ""function"": ""derive_statuses_transit_compatible"", ""parameters"": {""fleeti"": [""asset_type"", ""asset_subtype""]}, ""description"": ""Derived from asset_type and asset_subtype, checks compatibility matrix for transit status""}]",string,,,statuses.transit.compatible,calculated,"""""""""true""""""""",,"Calculated: derive from asset_type and asset_subtype using derive_statuses_transit_compatible function. Check asset type/subtype against compatibility matrix (Transit: Phone all subtypes, Equipment.Undefined, All Vehicle subtypes except excluded). Supported: Phone (all subtypes), Equipment.Undefined, All Vehicle subtypes (except those explicitly excluded). NOT supported: Site.Undefined, Site.Coldroom, Equipment.FuelTank, Equipment.ElectricGenerator. Return true if asset type/subtype is compatible, false otherwise.",,,inactive,simple_value,,1.0.0,,
statuses_transit_last_changed_at,status,"Calculated: derive from statuses_transit_code using derive_statuses_transit_last_changed_at function. Updates when status family code changes (not on every packet). Backend compares current statuses_transit_code with previous value. If different, update timestamp to current ISO8601 UTC time. If same, keep previous timestamp unchanged. Used to calculate duration of current transit status (e.g., ""parked for 2h"", ""in_transit since 10:30""). Enables transit duration tracking and timeline features.

Pseudo code:
if (current_statuses_transit_code !== previous_statuses_transit_code) {
  statuses_transit_last_changed_at = now()  // ISO8601 UTC timestamp
} else {
  statuses_transit_last_changed_at = previous_statuses_transit_last_changed_at  // keep unchanged
}","[{""priority"": 1, ""type"": ""calculated"", ""calculation_type"": ""function_reference"", ""function"": ""derive_statuses_transit_last_changed_at"", ""parameters"": {""fleeti"": [""statuses_transit_code""]}, ""description"": ""Derived from statuses_transit_code, updates when transit status changes""}]",date,,,statuses.transit.last_changed_at,calculated,"""""""""2025-01-18T14:30:45Z""""""""",,"Calculated: Backend compares current statuses_transit_code with previous value. If different, update timestamp to current ISO8601 UTC time. If same, keep previous timestamp unchanged. Used to calculate duration of current transit status (e.g., ""parked for 2h"", ""in_transit since 10:30""). Updates only when transit status changes (not on every packet).",,,inactive,simple_value,,1.0.0,,
geofences,status,,,array,,,geofences[],,,,,,,inactive,array,,1.0.0,,
geofences_geofence_id,status,,,string,,,geofences.geofence_id,,"""""""""15""""""""",,,,,inactive,simple_value,,1.0.0,,
geofences_geofence_name,status,,,string,,,geofences.geofence_name,,"""""""""Service Area""""""""",,,,,inactive,simple_value,,1.0.0,,
ignition_value,power,"Calculated: derive from asset_installation_ignition_input_number, inputs_individual_input_1, inputs_individual_input_2, inputs_individual_input_3, and inputs_individual_input_4 using derive_ignition_value function. Read ignition input number from asset.installation.ignition_input_number (default to 1 if not specified). Read digital input state from the corresponding individual input field: inputs_individual_input_1 (if ignition_input_number = 1), inputs_individual_input_2 (if ignition_input_number = 2), inputs_individual_input_3 (if ignition_input_number = 3), or inputs_individual_input_4 (if ignition_input_number = 4). If ignition_input_number is not available, fallback to inputs_individual_input_1. If anything else fails, return null. This is the primary ignition field used by the rest of the Fleeti system for status computation and business logic.

Pseudo code:
ignition_input_number = asset_installation_ignition_input_number || 1  // default to 1
ignition_state = null
if (ignition_input_number === 1) {
  ignition_state = inputs_individual_input_1
} else if (ignition_input_number === 2) {
  ignition_state = inputs_individual_input_2
} else if (ignition_input_number === 3) {
  ignition_state = inputs_individual_input_3
} else if (ignition_input_number === 4) {
  ignition_state = inputs_individual_input_4
} else {
  ignition_state = null  // invalid input number
}
return ignition_state","[{""priority"": 1, ""type"": ""calculated"", ""calculation_type"": ""function_reference"", ""function"": ""derive_ignition_value"", ""parameters"": {""fleeti"": [""inputs_individual_input_1"", ""inputs_individual_input_2"", ""inputs_individual_input_3"", ""inputs_individual_input_4""]}, ""description"": ""Derived from asset installation metadata (ignition_input_number) and individual input fields to determine ignition state. Uses asset.installation.ignition_input_number to select the correct input field (1-4), defaults to input 1 if metadata unavailable.""}]",boolean,,,ignition.value,,"""""""""boolean""""""""",,"Read ignition input number from asset.installation.ignition_input_number (default to 1 if not specified). Read digital input state from the corresponding individual input field: inputs_individual_input_1 (if ignition_input_number = 1), inputs_individual_input_2 (if ignition_input_number = 2), inputs_individual_input_3 (if ignition_input_number = 3), or inputs_individual_input_4 (if ignition_input_number = 4). If ignition_input_number is not available, fallback to inputs_individual_input_1. If anything else fails, return null. This is the primary ignition field used by the rest of the Fleeti system for status computation and business logic.",inactive,simple_value,,1.0.0,,,,
ignition_last_changed_at,power,"Calculated: derive from ignition_value using derive_ignition_last_changed_at function. Updates when ignition state changes (not on every packet). Backend compares current ignition_value with previous value. If different, update timestamp to current ISO8601 UTC time. If same, keep previous timestamp unchanged. Used to calculate duration of current ignition state (e.g., ""ignition on for 2h"", ""ignition off since yesterday""). Enables ignition duration tracking and timeline features.

Pseudo code:
if (current_ignition_value !== previous_ignition_value) {
  ignition_last_changed_at = now()  // ISO8601 UTC timestamp
} else {
  ignition_last_changed_at = previous_ignition_last_changed_at  // keep unchanged
}","[{""priority"": 1, ""type"": ""calculated"", ""calculation_type"": ""function_reference"", ""function"": ""derive_ignition_last_changed_at"", ""parameters"": {""fleeti"": [""ignition_value""]}, ""description"": ""Derived from ignition_value, updates when ignition state changes""}]",string,,,ignition.last_changed_at,,"""""""""2025-01-18T14:30:45Z""""""""",,,,,inactive,simple_value,,1.0.0,,
inputs_individual_input_1,io,"Prioritized: extract bit 0 from inputs bitmask at root level using extract_bit_from_bitmask function (priority 1), then Navixy avl_io_1 (path: params.avl_io_1, priority 2) - Digital Input 1 state. Values: 0 = low/inactive, 1 = high/active. Semantic meaning (e.g., ignition, door sensor) is defined in asset.installation.* metadata. Used to compute canonical fields like power.ignition.

Pseudo code:
if (inputs bitmask is available) {
  io_input_1 = extractBit(inputs, 0)  // extract bit 0 from Digital Inputs Bitmask at root level
} else if (avl_io_1 is available) {
  io_input_1 = avl_io_1  // fallback: direct mapping from params.avl_io_1
} else {
  io_input_1 = null
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""extract_bit_from_bitmask"",
    ""parameters"": {
      ""provider"": {
        ""navixy"": ""inputs""
      }
    },
    ""description"": ""Extract bit 0 from Digital Inputs Bitmask at root level""
  },
  {
    ""priority"": 2,
    ""type"": ""direct"",
    ""source_type"": ""provider"",
    ""provider"": ""navixy"",
    ""field"": ""avl_io_1"",
    ""path"": ""params.avl_io_1"",
    ""description"": ""Digital Input 1 from Navixy (fallback)""
  }
]",boolean,,Digital Input 1,inputs.individual.input_1,,"""""""""boolean""""""""",,"Navixy: avl_io_1 (Digital Input 1), inputs (Digital Inputs Bitmask, bit 0)	Digital input 1 state. Values: 0 = low/inactive, 1 = high/active. Semantic meaning (e.g., ignition, door sensor) is defined in asset.installation.* metadata. Used to compute canonical fields like power.ignition. If only bitmask is available, transformation pipeline extracts bit 0.So basically, we take AVLIO1 as a priority input direct mapping, and we take inputs from root level packet plug. We have a bit mask, and we take the bit 0. ",,,inactive,simple_value,,1.0.0,,
inputs_individual_input_2,io,"Prioritized: extract bit 1 from inputs bitmask at root level using extract_bit_from_bitmask function (priority 1), then Navixy avl_io_2 (path: params.avl_io_2, priority 2) - Digital Input 2 state. Values: 0 = low/inactive, 1 = high/active. Semantic meaning (e.g., door sensor, alarm) is defined in asset.installation.* metadata. Used to compute canonical fields.

Pseudo code:
if (inputs bitmask is available) {
  io_input_2 = extractBit(inputs, 1)  // extract bit 1 from Digital Inputs Bitmask at root level
} else if (avl_io_2 is available) {
  io_input_2 = avl_io_2  // fallback: direct mapping from params.avl_io_2
} else {
  io_input_2 = null
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""extract_bit_from_bitmask"",
    ""parameters"": {
      ""provider"": {
        ""navixy"": ""inputs""
      }
    },
    ""description"": ""Extract bit 1 from Digital Inputs Bitmask at root level""
  },
  {
    ""priority"": 2,
    ""type"": ""direct"",
    ""source_type"": ""provider"",
    ""provider"": ""navixy"",
    ""field"": ""avl_io_2"",
    ""path"": ""params.avl_io_2"",
    ""description"": ""Digital Input 2 from Navixy (fallback)""
  }
]",boolean,,Digital Input 2,inputs.individual.input_2,,"""""""""boolean""""""""",,,,,inactive,simple_value,,1.0.0,,
inputs_individual_input_3,io,"Prioritized: extract bit 2 from inputs bitmask at root level using extract_bit_from_bitmask function (priority 1), then Navixy avl_io_3 (path: params.avl_io_3, priority 2) - Digital Input 3 state. Values: 0 = low/inactive, 1 = high/active. Semantic meaning (e.g., door sensor, alarm) is defined in asset.installation.* metadata. Used to compute canonical fields.

Pseudo code:
if (inputs bitmask is available) {
  io_input_3 = extractBit(inputs, 2)  // extract bit 2 from Digital Inputs Bitmask at root level
} else if (avl_io_3 is available) {
  io_input_3 = avl_io_3  // fallback: direct mapping from params.avl_io_3
} else {
  io_input_3 = null
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""extract_bit_from_bitmask"",
    ""parameters"": {
      ""provider"": {
        ""navixy"": ""inputs""
      }
    },
    ""description"": ""Extract bit 2 from Digital Inputs Bitmask at root level""
  },
  {
    ""priority"": 2,
    ""type"": ""direct"",
    ""source_type"": ""provider"",
    ""provider"": ""navixy"",
    ""field"": ""avl_io_3"",
    ""path"": ""params.avl_io_3"",
    ""description"": ""Digital Input 3 from Navixy (fallback)""
  }
]",boolean,,Digital Input 3,inputs.individual.input_3,,"""""""""boolean""""""""",,,,,inactive,simple_value,,1.0.0,,
inputs_individual_input_4,io,"Prioritized: extract bit 3 from inputs bitmask at root level using extract_bit_from_bitmask function (priority 1), then Navixy avl_io_4 (path: params.avl_io_4, priority 2) - Digital Input 4 state (also functions as pulse counter). Values: 0 = low/inactive, 1 = high/active. Pulse count resets when records are saved. Semantic meaning (e.g., door sensor, alarm) is defined in asset.installation.* metadata. Used to compute canonical fields.

Pseudo code:
if (inputs bitmask is available) {
  io_input_4 = extractBit(inputs, 3)  // extract bit 3 from Digital Inputs Bitmask at root level
} else if (avl_io_4 is available) {
  io_input_4 = avl_io_4  // fallback: direct mapping from params.avl_io_4
} else {
  io_input_4 = null
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""extract_bit_from_bitmask"",
    ""parameters"": {
      ""provider"": {
        ""navixy"": ""inputs""
      }
    },
    ""description"": ""Extract bit 3 from Digital Inputs Bitmask at root level""
  },
  {
    ""priority"": 2,
    ""type"": ""direct"",
    ""source_type"": ""provider"",
    ""provider"": ""navixy"",
    ""field"": ""avl_io_4"",
    ""path"": ""params.avl_io_4"",
    ""description"": ""Digital Input 4 from Navixy (fallback)""
  }
]",boolean,,Digital Input 4,inputs.individual.input_4,,"""""""""boolean""""""""",,,,,inactive,simple_value,,1.0.0,,
outputs_individual_output_1,io,"Prioritized: extract bit 0 from outputs bitmask at root level using extract_bit_from_bitmask function (priority 1), then Navixy avl_io_179 (path: params.avl_io_179, priority 2) - Digital Output 1 state. Values: 0 = inactive, 1 = active. Semantic meaning (e.g., immobilizer relay) is defined in asset.installation.* metadata. Used for immobilization control and status computation.

Pseudo code:
if (outputs bitmask is available) {
  io_output_1 = extractBit(outputs, 0)  // extract bit 0 from Output Status Bitmask at root level
} else if (avl_io_179 is available) {
  io_output_1 = avl_io_179  // fallback: direct mapping from params.avl_io_179
} else {
  io_output_1 = null
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""extract_bit_from_bitmask"",
    ""parameters"": {
      ""provider"": {
        ""navixy"": ""outputs""
      }
    },
    ""description"": ""Extract bit 0 from Output Status Bitmask at root level""
  },
  {
    ""priority"": 2,
    ""type"": ""direct"",
    ""source_type"": ""provider"",
    ""provider"": ""navixy"",
    ""field"": ""avl_io_179"",
    ""path"": ""params.avl_io_179"",
    ""description"": ""Digital Output 1 from Navixy (fallback)""
  }
]",boolean,,Digital Output 1,outputs.individual.output_1,,"""""""""boolean""""""""",,"We should use AVL inside the Params object, or in priority to use outputs at the root level of the packet. ",,,inactive,simple_value,,1.0.0,,
outputs_individual_output_2,io,"Prioritized: extract bit 1 from outputs bitmask at root level using extract_bit_from_bitmask function (priority 1), then Navixy avl_io_180 (path: params.avl_io_180, priority 2) - Digital Output 2 state. Values: 0 = inactive, 1 = active. Semantic meaning (e.g., immobilizer relay) is defined in asset.installation.* metadata. Used for immobilization control and status computation.

Pseudo code:
if (outputs bitmask is available) {
  io_output_2 = extractBit(outputs, 1)  // extract bit 1 from Output Status Bitmask at root level
} else if (avl_io_180 is available) {
  io_output_2 = avl_io_180  // fallback: direct mapping from params.avl_io_180
} else {
  io_output_2 = null
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""extract_bit_from_bitmask"",
    ""parameters"": {
      ""provider"": {
        ""navixy"": ""outputs""
      }
    },
    ""description"": ""Extract bit 1 from Output Status Bitmask at root level""
  },
  {
    ""priority"": 2,
    ""type"": ""direct"",
    ""source_type"": ""provider"",
    ""provider"": ""navixy"",
    ""field"": ""avl_io_180"",
    ""path"": ""params.avl_io_180"",
    ""description"": ""Digital Output 2 from Navixy (fallback)""
  }
]",boolean,,Digital Output 2,outputs.individual.output_2,,"""""""""boolean""""""""",,"We should use AVL inside the Params object, or in priority to use outputs at the root level of the packet. ",,,inactive,simple_value,,1.0.0,,
outputs_individual_output_3,io,"Prioritized: extract bit 2 from outputs bitmask at root level using extract_bit_from_bitmask function (priority 1), then Navixy avl_io_380 (path: params.avl_io_380, priority 2) - Digital Output 3 state. Values: 0 = inactive, 1 = active. Semantic meaning (e.g., immobilizer relay) is defined in asset.installation.* metadata. Used for immobilization control and status computation.

Pseudo code:
if (outputs bitmask is available) {
  io_output_3 = extractBit(outputs, 2)  // extract bit 2 from Output Status Bitmask at root level
} else if (avl_io_380 is available) {
  io_output_3 = avl_io_380  // fallback: direct mapping from params.avl_io_380
} else {
  io_output_3 = null
}","[
  {
    ""priority"": 1,
    ""type"": ""calculated"",
    ""calculation_type"": ""function_reference"",
    ""function"": ""extract_bit_from_bitmask"",
    ""parameters"": {
      ""provider"": {
        ""navixy"": ""outputs""
      }
    },
    ""description"": ""Extract bit 2 from Output Status Bitmask at root level""
  },
  {
    ""priority"": 2,
    ""type"": ""direct"",
    ""source_type"": ""provider"",
    ""provider"": ""navixy"",
    ""field"": ""avl_io_380"",
    ""path"": ""params.avl_io_380"",
    ""description"": ""Digital Output 3 from Navixy (fallback)""
  }
]",boolean,,Digital Output 3,outputs.individual.output_3,,"""""""""boolean""""""""",,"We should use AVL inside the Params object, or in priority to use outputs at the root level of the packet. ",,,inactive,simple_value,,1.0.0,,
movement_last_updated_at,motion,"Calculated: derive from provider fields (can_speed, obd_speed, avl_io_24, avl_io_37, avl_io_81, avl_io_240, moving) using derive_movement_last_updated_at function. Set to msg_time when any motion-related provider field is present in the telemetry packet. Provider fields that indicate motion data: can_speed (CAN Speed), obd_speed (OBD Speed), avl_io_24 (Speed), avl_io_37 (Vehicle Speed), avl_io_81 (Vehicle Speed), avl_io_240 (Movement), moving (Is Moving). Indicates when motion data (speed, is_moving, etc.) was last updated. Updates on every packet that contains any of these motion provider fields.

Pseudo code:
if (hasMotionProviderField(packet)) {
  movement_last_updated_at = msg_time  // ISO8601 UTC timestamp
} else {
  movement_last_updated_at = null  // no motion data in packet
}","[{""priority"": 1, ""type"": ""calculated"", ""calculation_type"": ""function_reference"", ""function"": ""derive_movement_last_updated_at"", ""parameters"": {}, ""description"": ""Derived from provider fields (can_speed, obd_speed, avl_io_24, avl_io_37, avl_io_81, avl_io_240, moving). Set to msg_time when any motion-related provider field is present in the telemetry packet.""}]",date,,Movement Last Updated At,motion.last_updated_at,calculated,"""""""""2025-01-18T14:30:45Z""""""""",,"Set to msg_time when any motion-related provider field is present in the telemetry packet. Provider fields that indicate motion data: can_speed (CAN Speed), obd_speed (OBD Speed), avl_io_24 (Speed), avl_io_37 (Vehicle Speed), avl_io_81 (Vehicle Speed), avl_io_240 (Movement), moving (Is Moving). Indicates when motion data (speed, is_moving, etc.) was last updated. Updates on every packet that contains any of these motion provider fields.",P1,,inactive,simple_value,,1.0.0,,
speed,motion,"Prioritized: Navixy can_speed (path: params.can_speed, priority 1), then Navixy obd_speed (path: params.obd_speed, priority 2), then Navixy avl_io_24 (path: params.avl_io_24, priority 3), then Navixy avl_io_37 (path: params.avl_io_37, priority 4), then Navixy avl_io_81 (path: params.avl_io_81, priority 5), then Navixy speed (path: speed, priority 6) - Speed in km/h. GNSS Speed is the fallback. Use highest priority available source.","[{""priority"": 1, ""type"": ""direct"", ""source_type"": ""provider"", ""provider"": ""navixy"", ""field"": ""can_speed"", ""path"": ""params.can_speed"", ""description"": ""Speed from CAN Speed (priority 1)""}, {""priority"": 2, ""type"": ""direct"", ""source_type"": ""provider"", ""provider"": ""navixy"", ""field"": ""obd_speed"", ""path"": ""params.obd_speed"", ""description"": ""Speed from OBD Speed (priority 2)""}, {""priority"": 3, ""type"": ""direct"", ""source_type"": ""provider"", ""provider"": ""navixy"", ""field"": ""avl_io_24"", ""path"": ""params.avl_io_24"", ""description"": ""Speed from avl_io_24 (priority 3)""}, {""priority"": 4, ""type"": ""direct"", ""source_type"": ""provider"", ""provider"": ""navixy"", ""field"": ""avl_io_37"", ""path"": ""params.avl_io_37"", ""description"": ""Speed from Vehicle Speed avl_io_37 (priority 4)""}, {""priority"": 5, ""type"": ""direct"", ""source_type"": ""provider"", ""provider"": ""navixy"", ""field"": ""avl_io_81"", ""path"": ""params.avl_io_81"", ""description"": ""Speed from Vehicle Speed avl_io_81 (priority 5)""}, {""priority"": 6, ""type"": ""direct"", ""source_type"": ""provider"", ""provider"": ""navixy"", ""field"": ""speed"", ""path"": ""speed"", ""description"": ""Speed from GNSS Speed (priority 6, fallback)""}]",number,,Speed in km/h,motion.speed.value,prioritized,"""""""""65""""""""",,"Prioritized mapping from Navixy: can_speed (CAN Speed, priority 1), obd_speed (OBD Speed, priority 2), avl_io_24 (Speed, priority 3), avl_io_37 (Vehicle Speed, priority 4), avl_io_81 (Vehicle Speed, priority 5), speed (GNSS Speed, priority 6). GNSS Speed is the fallback. Use highest priority available source.",P0,,inactive,simple_value,km/h,1.0.0,,
is_moving_value,motion,"Prioritized: Navixy avl_io_240 (path: params.avl_io_240, priority 1), then Navixy moving (path: params.moving, priority 2) - Movement status. Values: 0 = Movement Off, 1 = Movement On. Indicates whether the asset is currently moving.","[{""priority"": 1, ""type"": ""direct"", ""source_type"": ""provider"", ""provider"": ""navixy"", ""field"": ""avl_io_240"", ""path"": ""params.avl_io_240"", ""description"": ""Movement status from avl_io_240 (priority 1)""}, {""priority"": 2, ""type"": ""direct"", ""source_type"": ""provider"", ""provider"": ""navixy"", ""field"": ""moving"", ""path"": ""params.moving"", ""description"": ""Movement status from moving field (priority 2)""}]",number,,Movement Status: yes/no,motion.is_moving.value,prioritized,"""""""""1""""""""",,"Prioritized mapping from Navixy: avl_io_240 (Movement, priority 1), moving (Is Moving, priority 2). Values: 0 = Movement Off, 1 = Movement On. Indicates whether the asset is currently moving.",P1,,inactive,simple_value,,1.0.0,,
is_moving_last_updated_at,motion,"Calculated: derive from is_moving_value using derive_is_moving_last_updated_at function. Updates when movement status changes (not on every packet). Backend compares current is_moving_value with previous value. If different, update timestamp to current ISO8601 UTC time. If same, keep previous timestamp unchanged. Used to show ""vehicle stopped since X"" and calculate dwell times. Enables movement duration tracking and timeline features.

Pseudo code:
if (current_is_moving_value !== previous_is_moving_value) {
  is_moving_last_updated_at = now()  // ISO8601 UTC timestamp
} else {
  is_moving_last_updated_at = previous_is_moving_last_updated_at  // keep unchanged
}","[{""priority"": 1, ""type"": ""calculated"", ""calculation_type"": ""function_reference"", ""function"": ""derive_is_moving_last_updated_at"", ""parameters"": {""fleeti"": [""is_moving_value""]}, ""description"": ""Derived from is_moving_value, updates when movement status changes""}]",date,is_moving_value,Last Time for when the asset has moved.,motion.is_moving.last_changed_at,calculated,"""""""""2025-01-18T14:30:45Z""""""""",,"Calculated: Backend compares current is_moving.value with previous value. If different, update timestamp to current ISO8601 UTC time. If same, keep previous timestamp unchanged. Used to show ""vehicle stopped since X"" and calculate dwell times. Updates only when movement status changes (not on every packet).",P1,,inactive,simple_value,,1.0.0,,
