# YAML Configuration Generation Specification

**Status:** ✅ Specification  
**Last Updated:** 2025-01-16

This document specifies how to generate YAML configuration files from the Mapping Fields Database CSV, including required database joins, processing logic, and examples for each mapping type.

---

## Overview

The YAML configuration file is generated by:
1. Reading the Mapping Fields CSV
2. Joining with Fleeti Fields Database (for field metadata)
3. Joining with Provider Fields Database (for provider field metadata)
4. Processing mappings in dependency order
5. Generating YAML structure based on mapping type

## Field Name vs Field Path

**Critical Design Decision:** YAML configurations use **Field Names** (stable identifiers) instead of **Field Paths** (can change).

### Why Field Names?

- **Stability**: Field Names (`location_latitude`) do not change when Field Paths (`location.latitude` → `position.latitude`) are refactored
- **Resilience**: YAML configurations remain valid even when telemetry object structure changes
- **Maintainability**: Reduces configuration churn and breaking changes

### How It Works

1. **YAML Generation**: Uses Field Name (`location_latitude`) as mapping key and in dependencies/parameters
2. **Backend Resolution**: Backend maintains lookup table mapping Field Name → Field Path
3. **Runtime**: Backend resolves Field Name to current Field Path when reading telemetry data

### Example

**YAML (stable):**
```yaml
mappings:
  location_latitude:  # Field Name (never changes)
    type: "direct"
    source: "lat"
    # Field Path: location.latitude
```

**Backend Lookup:**
```python
FIELD_NAME_TO_PATH = {
    "location_latitude": "location.latitude",  # Updated if path changes
}
```

If Field Path changes to `position.latitude`, only the lookup table is updated. YAML remains unchanged.

---

## Database Joins Required

### Fleeti Fields Database Join

Join on `Fleeti Field` column to retrieve:
- `Name` → **Used as YAML key** (stable identifier, does not change)
- `Field Path` → Used for documentation/comments only (can change, resolved at runtime)
- `Unit` → Used for unit conversion detection
- `Data Type` → Used for validation
- `Structure Type` → Used for nested object handling
- `JSON Structure` → Used for validation examples

**Important:** Field Name (`Name`) is the **stable identifier** used in YAML keys, dependencies, and function parameters. Field Path can change without breaking YAML configurations. Backend resolves Field Name → Field Path at runtime.

### Provider Fields Database Join

Join on `Provider Fields` column (may be multiple, comma-separated) to retrieve:
- `Field Path` → Used to read from provider packets
- `Unit` → Used for unit conversion detection
- `Data Type` → Used for type validation
- `Availability` → Used for priority fallback logic

---

## YAML Structure

**Important:** YAML uses **Field Name** (stable identifier) as keys, not Field Path. Backend resolves Field Name → Field Path at runtime.

```yaml
version: "1.0.0"
provider: "navixy"
mappings:
  location_latitude:
    type: "direct"
    source: "lat"
    unit: "degrees"
    data_type: "number"
    # Field Path: location.latitude
  
  motion_speed:
    type: "prioritized"
    sources:
      - priority: 1
        field: "can_speed"
        path: "params.can_speed"
      - priority: 2
        field: "obd_speed"
        path: "params.obd_speed"
      - priority: 3
        field: "speed"
        path: "speed"
    unit: "m/s"
    data_type: "number"
    error_handling: "use_fallback"
    # Field Path: motion.speed (resolved at runtime)
  
  location_cardinal_direction:
    type: "calculated"
    calculation_type: "function_reference"
    function: "derive_cardinal_direction"
    parameters:
      heading: "location_heading"  # Field Name, not Field Path
    dependencies:
      - "location_heading"  # Field Name, not Field Path
    data_type: "string"
    # Field Path: location.cardinal_direction (resolved at runtime)
```

---

## Function Registry Pattern

The YAML configuration supports a **Function Registry Pattern** that makes configurations directly pluggable into backend code. This pattern enables:

1. **Direct Function Calls**: Backend can call functions directly from a registry
2. **Parameter Mapping**: Structured mapping of function parameters to Fleeti field names (stable identifiers)
3. **Validation**: Backend can validate function existence and parameter correctness
4. **Implementation Guidance**: YAML comments provide developer guidance without breaking parsing
5. **Stable Configuration**: Uses Field Names instead of Field Paths, making configs resilient to path changes

### Calculation Execution Modes

There are two calculation execution modes, each with different YAML structures:

#### 1. Function Reference (`function_reference`) - **Default for All Calculated Fields**

**When to Use:** 
- Function exists (or should exist) in backend function registry
- **Default choice** for all calculated fields - use this for function calls
- Can be implemented as a pure function (takes inputs, returns output)
- Reusable across providers or contexts
- All calculated logic should use `function_reference` - functions can handle complex logic internally

**Decision Rule:** Use `function_reference` for all calculated fields that require function calls. Use `formula` only for simple mathematical expressions that can be parsed and evaluated directly.

**YAML Structure:**
```yaml
mappings:
  {Fleeti Field Name}:
    type: "calculated"
    calculation_type: "function_reference"
    function: "function_name"  # Must exist in FUNCTION_REGISTRY
    formula: "(field1 / field2) * 100"  # Optional: embed formula if available and embeddable
    parameters:
      param1: "fleeti_field_name_1"
      param2: "fleeti_field_name_2"
    dependencies:
      - "fleeti_field_name_1"  # Field Names, not Field Paths
      - "fleeti_field_name_2"
    data_type: {Fleeti Data Type}
    # Implementation: path/to/implementation.py
    # Description: What the function does
    # Algorithm: Step-by-step algorithm description
    # Field Path: {Fleeti Field Path}
```

**Example 1: Function reference without formula**
```yaml
mappings:
  location_cardinal_direction:
    type: "calculated"
    calculation_type: "function_reference"
    function: "derive_cardinal_direction"
    parameters:
      heading: "location_heading"  # Field Name, not Field Path
    # Implementation: telemetry-transformation-service/src/functions/cardinal.py
    # Description: Converts heading angle (0-359°) to cardinal direction
    # Algorithm: Add 22.5° offset, divide by 45°, map to 8 directions (N, NE, E, SE, S, SW, W, NW)
    # Field Path: location.cardinal_direction (resolved at runtime)
    dependencies:
      - "location_heading"  # Field Name, not Field Path
    data_type: "string"
```

**Example 2: Function reference with embeddable formula**
```yaml
mappings:
  fuel_consumption_rate:
    type: "calculated"
    calculation_type: "function_reference"
    function: "calculate_fuel_consumption_rate"
    formula: "(fuel_consumed_trip / trip_distance) * 100"  # Optional: embed formula if available
    parameters:
      fuel_consumed: "fuel_consumed_trip"
      distance: "trip_distance"
    # Implementation: telemetry-transformation-service/src/functions/fuel.py
    # Description: Calculates fuel consumption rate as percentage
    # Algorithm: Divide fuel consumed by trip distance, multiply by 100
    # Field Path: fuel.consumption_rate (resolved at runtime)
    dependencies:
      - "fuel_consumed_trip"
      - "trip_distance"
    data_type: "number"
```

**Example 3: Function reference with complex logic (implementation details in comments)**
```yaml
mappings:
  location_geocoded_address:
    type: "calculated"
    calculation_type: "function_reference"
    function: "geocode_location"
    parameters:
      latitude: "location_latitude"
      longitude: "location_longitude"
    # Implementation: telemetry-transformation-service/src/functions/geocoding.py
    # Description: Converts lat/lng to formatted address using Google Geocoding API
    # Algorithm:
    #   1. Call Google Geocoding API with lat/lng
    #   2. Extract formatted_address from response
    #   3. Cache result for 24 hours (same location)
    #   4. Return formatted address string
    # Field Path: location.geocoded_address (resolved at runtime)
    dependencies:
      - "location_latitude"
      - "location_longitude"
    data_type: "string"
```

#### 2. Formula (`formula`) - **For Simple Math Only**

**When to Use:** Simple mathematical expressions that can be parsed and evaluated directly without requiring a function call. Use sparingly - prefer `function_reference` for most calculations.

**YAML Structure:**
```yaml
mappings:
  {Fleeti Field Name}:
    type: "calculated"
    calculation_type: "formula"
    formula: "(field_name1 / field_name2) * 100"  # Parseable expression using Field Names
    dependencies:
      - "field_name1"  # Field Names, not Field Paths
      - "field_name2"
    data_type: {Fleeti Data Type}
    # Field Path: {Fleeti Field Path}
```

**Example:**
```yaml
mappings:
  fuel_consumption_rate:
    type: "calculated"
    calculation_type: "formula"
    formula: "(fuel_consumed_trip / trip_distance) * 100"  # Field Names in formula
    dependencies:
      - "fuel_consumed_trip"  # Field Names
      - "trip_distance"
    data_type: "number"
    # Field Path: fuel.consumption_rate (resolved at runtime)
```

**Note:** For most calculations, prefer `function_reference` even if a formula exists. The `formula` type should only be used for very simple expressions that don't warrant a function call. If a formula can be embedded, include it as an optional `formula` parameter in `function_reference` instead.

### Parameter Mapping Format

For `function_reference` type, parameters must be structured as a mapping from function parameter names to **Fleeti Field Names** (stable identifiers):

```yaml
parameters:
  function_param_name: "fleeti_field_name"  # Field Name, NOT Field Path
```

**Rules:**
- Parameter names must match function signature
- **Field Names** (not Field Paths) must exist in dependencies
- All function parameters must be mapped
- Field Names use underscore notation (e.g., `location_heading`)
- Backend resolves Field Name → Field Path at runtime using lookup table

### Implementation Guidance Comments

YAML comments (lines starting with `#`) can be used to provide implementation guidance without affecting YAML parsing:

```yaml
# Implementation: path/to/file.py
# Description: What the function does
# Algorithm: Step-by-step algorithm description
# Error Handling: How errors should be handled
```

These comments are:
- **Ignored by YAML parser** (safe to include)
- **Visible to developers** (helpful for implementation)
- **Not validated** (informational only)

---

## Mapping Type Processing

### 1. Direct Mapping

**Required Columns:**
- `Fleeti Field` (Name - stable identifier)
- `Fleeti Field Path` (for reference/documentation)
- `Provider Field Paths` (single)
- `Fleeti Unit`
- `Fleeti Data Type`

**YAML Generation:**

```yaml
mappings:
  {Fleeti Field Name}:
    type: "direct"
    source: {Provider Field Paths}
    unit: {Fleeti Unit}
    data_type: {Fleeti Data Type}
    # Field Path: {Fleeti Field Path}
```

**Optional Columns (if provided):**
- `Unit Conversion` → Add `unit_conversion` key (only if units differ and conversion needed)
- `Default Value` → Add `default` key (optional, typically `null`)
- `Error Handling` → Add `error_handling` key (optional, defaults to `"return_null"` for direct mappings)

**Example:**

```yaml
mappings:
  location_latitude:
    type: "direct"
    source: "lat"
    unit: "degrees"
    data_type: "number"
    default: null
    # Field Path: location.latitude
```

**Note:** `unit_conversion` should only be included if Provider Unit ≠ Fleeti Unit and both are non-empty. See Auto-Generation Rules section for details.

---

### 2. Prioritized Mapping

**Required Columns:**
- `Fleeti Field` (Name - stable identifier)
- `Fleeti Field Path` (for reference/documentation)
- `Provider Fields` (comma-separated)
- `Provider Field Paths` (comma-separated)
- `Priority JSON`
- `Fleeti Unit`
- `Fleeti Data Type`

**YAML Generation:**

1. Parse `Priority JSON` to get priority order
2. For each provider field in priority order:
   - Join with Provider Fields DB to get `Field Path`
   - Add to `sources` array with priority

```yaml
mappings:
  {Fleeti Field Name}:
    type: "prioritized"
    sources:
      - priority: {priority}
        field: {Provider Field Name}
        path: {Provider Field Path}
      # ... more sources in priority order
    unit: {Fleeti Unit}
    data_type: {Fleeti Data Type}
    error_handling: {Error Handling or "use_fallback"}
    # Field Path: {Fleeti Field Path}
```

**Auto-Generation Rules:**
- `error_handling`: Default to `"use_fallback"` if not specified
- `Unit Conversion`: Auto-generate only if `Provider Unit` ≠ `Fleeti Unit` AND both are valid (see Unit Conversion rules)

**Example:**

```yaml
mappings:
  location_precision_hdop:
    type: "prioritized"
    sources:
      - priority: 1
        field: "hdop"
        path: "hdop"
      - priority: 2
        field: "avl_io_182"
        path: "params.avl_io_182"
    unit: "none"
    data_type: "number"
    error_handling: "use_fallback"
    # Field Path: location.precision.hdop (resolved at runtime)
```

---

### 3. Calculated Mapping

**Required Columns:**
- `Fleeti Field` (Name - stable identifier)
- `Fleeti Field Path` (for reference/documentation)
- `Calculation Type` (determines YAML structure)
- `Computation Approach` (automatically populated via Notion rollup from Fleeti Fields Database relation)
- `Fleeti Data Type`

**YAML Generation varies by Calculation Type:**

#### If `calculation_type = "function_reference"`:

**Required Additional Columns:**
- `Backend Function Name` → Maps to `function` field
- `Function Parameters` → Maps to `parameters` field (structured mapping using Field Names)

**Optional Additional Columns:**
- `Computation Approach` → Maps to `# Computation Approach:` comment (multi-line support)

**YAML Generation:**

```yaml
mappings:
  {Fleeti Field Name}:
    type: "calculated"
    calculation_type: "function_reference"
    function: {Backend Function Name}  # Must exist in FUNCTION_REGISTRY
    parameters:
      {param1}: "{fleeti_field_name_1}"
      {param2}: "{fleeti_field_name_2}"
    dependencies:
      - "{fleeti_field_name_1}"  # Field Names, not Field Paths
      - "{fleeti_field_name_2}"
    data_type: {Fleeti Data Type}
    # Field Path: {Fleeti Field Path}
    # Computation Approach: {Computation Approach from Fleeti Fields CSV}
```

**Example 1: Function reference with computation approach**

```yaml
mappings:
  location_cardinal_direction:
    type: "calculated"
    calculation_type: "function_reference"
    function: "derive_cardinal_direction"
    parameters:
      heading: "location_heading"  # Field Name, not Field Path
    dependencies:
      - "location_heading"  # Field Name, not Field Path
    data_type: "string"
    # Field Path: location.cardinal_direction (resolved at runtime)
    # Computation Approach: Derived from location.heading
    #   dirs = ["N","NE","E","SE","S","SW","W","NW"];
    #   cardinal = dirs[Math.floor((heading + 22.5) % 360 / 45)];
```

**Example 2: Function reference with multi-line computation approach**

```yaml
mappings:
  location_geocoded_address:
    type: "calculated"
    calculation_type: "function_reference"
    function: "geocode_location"
    parameters:
      latitude: "location_latitude"
      longitude: "location_longitude"
    dependencies:
      - "location_latitude"
      - "location_longitude"
    data_type: "string"
    # Field Path: location.geocoded_address (resolved at runtime)
    # Computation Approach: Use external API (Google) to convert latitude and longitude into geocoded address.
```

#### If `calculation_type = "formula"` (kept for future use):

**Required Additional Columns:**
- `Computation Approach` → Parseable mathematical expression (using Field Names)

**YAML Generation:**

```yaml
mappings:
  {Fleeti Field Name}:
    type: "calculated"
    calculation_type: "formula"
    formula: {Computation Approach}  # Parseable expression using Field Names
    dependencies:
      - {Dependency Field Name 1}  # Field Names, not Field Paths
      - {Dependency Field Name 2}
    data_type: {Fleeti Data Type}
    # Field Path: {Fleeti Field Path}
```

**Note:** The `formula` type is kept for future use. Currently, all calculated fields use `function_reference` type with computation approach stored as comments.


---

### 4. Transformed Mapping

**Required Columns:**
- `Fleeti Field` (Name - stable identifier)
- `Fleeti Field Path` (for reference/documentation)
- `Transformation Rule` (may reference Field Names)
- `Service Integration` (can reference multiple services)
- `Fleeti Data Type`

**YAML Generation:**

```yaml
mappings:
  {Fleeti Field Name}:
    type: "transformed"
    transformation: {Transformation Rule}  # May reference Field Names
    service_fields:
      - {Service Field 1}  # Can be from Asset, Accessory, Geofence, Driver, etc.
      - {Service Field 2}
    data_type: {Fleeti Data Type}
    # Field Path: {Fleeti Field Path}
```

**Example:**

```yaml
mappings:
  fuel_level_liters:
    type: "transformed"
    transformation: "(fuel_level_percent / 100) * static.tank_capacity_liters"  # Field Names in formula
    service_fields:
      - "static.tank_capacity_liters"  # Asset Service field
    dependencies:
      - "fuel_level_percent"  # Field Name, not Field Path
    data_type: "number"
    # Field Path: fuel.level_liters (resolved at runtime)

mappings:
  geofence_name:
    type: "transformed"
    transformation: "geofence.name"  # References Geofence Service field
    service_fields:
      - "geofence.id"  # Geofence Service field
      - "geofence.name"  # Geofence Service field
    dependencies:
      - "location_latitude"  # Field Names
      - "location_longitude"
    data_type: "string"
    # Field Path: geofence.name (resolved at runtime)
```

---

### 5. I/O Mapped

**Required Columns:**
- `Fleeti Field` (Name - stable identifier)
- `Fleeti Field Path` (for reference/documentation)
- `I/O Mapping Config` (JSON)

**YAML Generation:**

1. Parse `I/O Mapping Config` JSON
2. Extract `default_source` and `installation_metadata`

```yaml
mappings:
  {Fleeti Field Name}:
    type: "io_mapped"
    default_source: {default_source from JSON}
    installation_metadata: {installation_metadata from JSON}
    data_type: {Fleeti Data Type}
    # Field Path: {Fleeti Field Path}
```

**Example:**

```yaml
mappings:
  power_ignition:
    type: "io_mapped"
    default_source: "io.inputs.individual.input_1"
    installation_metadata: "asset.installation.ignition_input_number"
    data_type: "boolean"
    # Field Path: power.ignition (resolved at runtime)
```

---

### 6. Asset-Integrated Mapping

**Required Columns:**
- `Fleeti Field` (Name - stable identifier)
- `Fleeti Field Path` (for reference/documentation)
- `Service Integration` (can reference multiple services)
- `Fleeti Data Type`

**YAML Generation:**

```yaml
mappings:
  {Fleeti Field Name}:
    type: "asset_integrated"
    service_fields:
      - {Service Field 1}  # Can be from Asset, Accessory, Geofence, Driver, etc.
      - {Service Field 2}
    data_type: {Fleeti Data Type}
    # Field Path: {Fleeti Field Path}
```

**Example:**

```yaml
mappings:
  asset_installation_ignition_input_number:
    type: "asset_integrated"
    service_fields:
      - "asset.installation.ignition_input_number"  # Asset Service field
    data_type: "number"
    # Field Path: asset.installation.ignition_input_number (resolved at runtime)

mappings:
  accessory_sensor_type:
    type: "asset_integrated"
    service_fields:
      - "accessory.id"  # Accessory Service field
      - "accessory.sensor.type"  # Accessory Service field
    data_type: "string"
    # Field Path: accessory.sensor.type (resolved at runtime)
```

---

## Backend Integration

### Function Registry Structure

The backend should maintain a function registry that maps function names to implementations:

```python
# telemetry-transformation-service/src/functions/registry.py

FUNCTION_REGISTRY = {
    "derive_cardinal_direction": {
        "function": derive_cardinal_direction,
        "signature": {
            "heading": {"type": "float", "required": True}
        },
        "returns": "str",
        "description": "Converts heading angle (0-359°) to cardinal direction"
    },
    "geocode_location": {
        "function": geocode_location,
        "signature": {
            "latitude": {"type": "float", "required": True},
            "longitude": {"type": "float", "required": True}
        },
        "returns": "str",
        "description": "Converts lat/lng to formatted address using Google Geocoding API"
    }
}
```

### Field Name → Field Path Resolution

**Important:** YAML uses **Field Names** (stable identifiers) as keys and in dependencies/parameters. Backend must resolve Field Names to Field Paths at runtime.

**Backend Lookup Table:**

The backend maintains a lookup table mapping Field Names to Field Paths. This table is updated when Field Paths change, but YAML configurations remain stable.

```python
# Field Name → Field Path lookup table (updated when paths change)
FIELD_NAME_TO_PATH = {
    "location_latitude": "location.latitude",
    "location_longitude": "location.longitude",
    "location_heading": "location.heading",
    "location_cardinal_direction": "location.cardinal_direction",
    "motion_speed": "motion.speed",
    "fuel_consumption_rate": "fuel.consumption_rate",
    # ... updated when Field Paths change
}

def resolve_field_path(field_name):
    """Resolve Field Name to Field Path"""
    return FIELD_NAME_TO_PATH.get(field_name, field_name)
```

### YAML Loader and Validation

The backend YAML loader should:

1. **Load YAML Configuration** (uses Field Names as keys)
2. **Resolve Field Names to Field Paths** (using lookup table)
3. **Validate Function References**
   - Check if `function` exists in `FUNCTION_REGISTRY`
   - Validate parameter names match function signature
   - Validate parameter Field Names exist in dependencies
4. **Resolve Parameter Mapping**
   - Map function parameter names to actual field values
   - Resolve Field Names to Field Paths
   - Extract values from telemetry object using Field Paths
5. **Execute Functions**
   - Call function with mapped parameters
   - Handle errors according to `error_handling` strategy

**Example YAML Loader:**

```python
def load_mapping_config(yaml_path):
    """Load and validate YAML mapping configuration"""
    import yaml
    
    config = yaml.safe_load(open(yaml_path))
    
    for field_name, mapping in config["mappings"].items():
        # Resolve Field Name to Field Path for reference
        field_path = resolve_field_path(field_name)
        
        if mapping["type"] == "calculated":
            if mapping["calculation_type"] == "function_reference":
                # Validate function exists
                func_name = mapping["function"]
                if func_name not in FUNCTION_REGISTRY:
                    raise ValueError(
                        f"Function '{func_name}' not found in registry for field '{field_name}' (path: {field_path})"
                    )
                
                # Validate parameters match function signature
                func_info = FUNCTION_REGISTRY[func_name]
                func_signature = func_info["signature"]
                
                for param_name in mapping["parameters"]:
                    if param_name not in func_signature:
                        raise ValueError(
                            f"Parameter '{param_name}' not in function '{func_name}' signature"
                        )
                
                # Validate all required parameters are provided
                for param_name, param_info in func_signature.items():
                    if param_info.get("required", True) and param_name not in mapping["parameters"]:
                        raise ValueError(
                            f"Required parameter '{param_name}' missing for function '{func_name}'"
                        )
                
                # Validate Field Names exist in dependencies
                for param_name, field_name_param in mapping["parameters"].items():
                    if field_name_param not in mapping.get("dependencies", []):
                        raise ValueError(
                            f"Field name '{field_name_param}' not in dependencies for parameter '{param_name}'"
                        )
    
    return config

def execute_calculated_field(mapping, telemetry_data):
    """Execute calculated field using function registry"""
    if mapping["calculation_type"] == "function_reference":
        func_name = mapping["function"]
        func_info = FUNCTION_REGISTRY[func_name]
        func = func_info["function"]
        
        # Map parameters: function_param -> field_value
        params = {}
        for param_name, field_name in mapping["parameters"].items():  # field_name is Field Name
            # Resolve Field Name to Field Path
            field_path = resolve_field_path(field_name)
            # Extract value from telemetry using Field Path
            params[param_name] = get_nested_value(telemetry_data, field_path)
        
        # Call function
        try:
            return func(**params)
        except Exception as e:
            # Handle error according to error_handling strategy
            error_handling = mapping.get("error_handling", "return_null")
            if error_handling == "return_null":
                return None
            elif error_handling == "throw_error":
                raise
            else:
                return None
    
    elif mapping["calculation_type"] == "formula":
        # Parse and evaluate formula
        return evaluate_formula(mapping["formula"], telemetry_data, mapping["dependencies"])
```

### Parameter Mapping Resolution

The backend must resolve parameter mappings by:

1. **Extracting Field Values**: Use field paths to extract values from telemetry object
2. **Type Conversion**: Convert values to match function signature types
3. **Null Handling**: Handle missing/null values according to error handling strategy

**Example:**

```python
def get_nested_value(obj, path):
    """Extract nested value from object using dot notation path"""
    keys = path.split(".")
    value = obj
    for key in keys:
        if isinstance(value, dict):
            value = value.get(key)
        elif isinstance(value, list) and key.isdigit():
            value = value[int(key)] if int(key) < len(value) else None
        else:
            return None
        if value is None:
            return None
    return value

# Example usage:
telemetry = {
    "location": {
        "heading": 45.0
    }
}

# Map parameter: heading -> location.heading
heading_value = get_nested_value(telemetry, "location.heading")  # Returns 45.0
```

### Error Handling

The backend should handle errors according to the `error_handling` field:

- **`return_null`**: Return `None` if function fails or parameters are missing
- **`throw_error`**: Raise exception if function fails
- **`use_fallback`**: Try next priority source (for prioritized mappings only)

---

## Processing Order

1. **Load Data:**
   - Read Mapping Fields CSV
   - Load Fleeti Fields Database (CSV or DB)
   - Load Provider Fields Database (CSV or DB)

2. **Build Dependency Graph:**
   - For each mapping, extract dependencies
   - Build directed graph
   - Detect circular dependencies (error)

3. **Topological Sort:**
   - Process mappings in dependency order
   - Direct mappings first (no dependencies)
   - Then prioritized mappings
   - Then calculated/transformed mappings (after dependencies)

4. **Generate YAML:**
   - For each mapping in sorted order:
     - Join with Fleeti Fields DB
     - Join with Provider Fields DB (if applicable)
     - Generate YAML entry based on mapping type
     - Apply auto-generation rules

5. **Validate:**
   - Check all required fields present
   - Validate JSON structures
   - Validate unit conversions
   - Check for missing dependencies

---

## Auto-Generation Rules

### Unit Conversion

**Rule:** Generate unit conversion only when `Provider Unit` ≠ `Fleeti Unit` AND both units are valid and non-empty.

**Skip Conditions (do NOT generate unit_conversion):**
1. **Empty or Unknown Units:** Skip if Provider Unit is empty, `"-"`, `"none"`, or `null`
2. **Equivalent Units:** Skip if units are equivalent (see Unit Equivalence Table below)
3. **Same Units:** Skip if Provider Unit exactly equals Fleeti Unit (case-insensitive)
4. **No Conversion Needed:** Skip if `Unit Conversion` column is explicitly empty and units match

**Unit Equivalence Table:**

| Unit Variants | Equivalent To |
|---------------|---------------|
| `m`, `meter`, `meters` | `meters` |
| `km`, `kilometer`, `kilometers` | `kilometers` |
| `deg`, `degree`, `degrees` | `degrees` |
| `°C`, `celsius`, `C` | `celsius` |
| `°F`, `fahrenheit`, `F` | `fahrenheit` |
| `km/h`, `kmh`, `kph` | `km/h` |
| `m/s`, `mps`, `meters_per_second` | `m/s` |
| `mph`, `miles_per_hour` | `mph` |
| `none`, `-`, `""` (empty) | No unit (skip conversion) |

**Detection Logic:**
1. Normalize both Provider Unit and Fleeti Unit (trim, lowercase, remove special chars)
2. Check equivalence table for matches
3. If equivalent → **Skip unit_conversion**
4. If different and both valid → Generate conversion rule
5. If Provider Unit is empty/unknown → **Skip unit_conversion**

**Conversion Rule Format:**

Use actionable conversion formulas, not descriptive text:

**Good Examples:**
```yaml
unit_conversion: "multiply by 0.277778"  # km/h → m/s
unit_conversion: "multiply by 3.6"      # m/s → km/h
unit_conversion: "divide by 1000"       # meters → kilometers
unit_conversion: "(value - 32) * 5/9"   # °F → °C
```

**Bad Examples (avoid):**
```yaml
unit_conversion: "Convert from degrees to degrees"  # Same unit
unit_conversion: "Convert from m to meters"         # Equivalent units
unit_conversion: "Convert from - to none"           # Empty unit
```

**Generation Examples:**

| Provider Unit | Fleeti Unit | Action | Result |
|---------------|-------------|--------|--------|
| `km/h` | `m/s` | Generate | `unit_conversion: "multiply by 0.277778"` |
| `degrees` | `degrees` | Skip | (no unit_conversion key) |
| `m` | `meters` | Skip | (equivalent units) |
| `-` | `none` | Skip | (empty/unknown units) |
| `km/h` | `km/h` | Skip | (same unit) |
| `°C` | `celsius` | Skip | (equivalent units) |

### Error Handling

**Rule:** Apply default error handling based on mapping type.

**Defaults:**
- `prioritized`: `"use_fallback"` (try next priority)
- `direct`: `"return_null"` (return null if source missing)
- `calculated`: `"return_null"` (return null if calculation fails)
- `transformed`: `"return_null"` (return null if transformation fails)

**Override:** If `Error Handling` column is specified, use that value.

### Default Values

**Rule:** Apply default value if source unavailable.

**Default:** `null` (unless `Default Value` column specifies otherwise)

---

## Validation Rules

### Required Field Validation

- **Fleeti Field Path**: Must exist in Fleeti Fields DB
- **Provider Field Paths**: Must exist in Provider Fields DB (for direct/prioritized)
- **Priority JSON**: Must be valid JSON (for prioritized)
- **I/O Mapping Config**: Must be valid JSON (for io_mapped)
- **Dependencies**: All dependencies must exist in Fleeti Fields DB

### Type Validation

- **Data Types**: Must match between Provider and Fleeti (or conversion specified)
- **Structure Types**: Nested objects must match JSON Structure from Fleeti Fields DB

### Unit Conversion Validation

- **Empty Units**: If Provider Unit is empty, `"-"`, `"none"`, or `null`, `unit_conversion` must NOT be generated
- **Equivalent Units**: If units are equivalent (see Unit Equivalence Table), `unit_conversion` must NOT be generated
- **Same Units**: If Provider Unit exactly equals Fleeti Unit, `unit_conversion` must NOT be generated
- **Format**: `unit_conversion` must use actionable formulas (e.g., `"multiply by 0.277778"`), not descriptive text (e.g., `"Convert from X to Y"`)

### Dependency Validation

- **Circular Dependencies**: Must not exist (error)
- **Missing Dependencies**: All dependencies must be defined before dependent field

---

## Example: Complete YAML Generation

### Input: Mapping Fields CSV Row

```csv
Mapping Name,Fleeti Field,Fleeti Field Path,Provider,Mapping Type,Status,Configuration Level,Provider Fields,Provider Field Paths,Provider Unit,Priority JSON,Computation Approach,Transformation Rule,I/O Mapping Config,Service Integration,Dependencies,Calculation Type,Default Value,Error Handling,Unit Conversion,Backend Function Name,Function Parameters,Fleeti Unit,Fleeti Data Type,Version Added,Last Modified,Notes
location.precision.hdop from Navixy,location_precision_hdop,location.precision.hdop,navixy,prioritized,planned,default,"hdop, avl_io_182","hdop, params.avl_io_182","none, none","[{""priority"": 1, ""field"": ""hdop""}, {""priority"": 2, ""field"": ""avl_io_182""}]",,,,,,,,,use_fallback,,,none,number,1.0.0,2025-01-16,Prioritized mapping: Horizontal Dilution of Precision
```

### Generated YAML

```yaml
mappings:
  location.precision.hdop:
    type: "prioritized"
    sources:
      - priority: 1
        field: "hdop"
        path: "hdop"
      - priority: 2
        field: "avl_io_182"
        path: "params.avl_io_182"
    unit: "none"
    data_type: "number"
    error_handling: "use_fallback"
```

**Note:** No `unit_conversion` is included because Provider Units (`none, none`) match Fleeti Unit (`none`), so conversion is skipped per Auto-Generation Rules.

---

## Implementation Notes

### Database Join Strategy

1. **Fleeti Fields Join:**
   - Create lookup dictionary: `fleeti_lookup[fleeti_field_name] = fleeti_field_data`
   - Join on `Fleeti Field` column

2. **Provider Fields Join:**
   - Create lookup dictionary: `provider_lookup[provider_field_name] = provider_field_data`
   - For comma-separated `Provider Fields`, split and join each

### Performance Considerations

- Pre-load all databases into memory (dictionaries)
- Process mappings in batches by mapping type
- Cache unit conversion lookups

### Error Handling

- **Missing Join Data**: Log warning, skip mapping or use defaults
- **Invalid JSON**: Log error, skip mapping
- **Circular Dependencies**: Log error, fail generation
- **Missing Dependencies**: Log warning, process anyway (may fail at runtime)

---

## Related Documentation

- **[Mapping Fields Database README](./README.md)**: Database schema and column definitions
- **[Fleeti Fields Database](../2-fleeti-fields/README.md)**: Target field definitions
- **[Provider Fields Database](../1-provider-fields/README.md)**: Source field definitions
- **[Mapping Rules](../../2-field-mappings/mapping-rules.md)**: Mapping rules documentation

---

**Last Updated:** 2025-01-16  
**Status:** ✅ Specification

